--- ftjam-2.5.2.orig/builds/unix/Jamrules.in
+++ ftjam-2.5.2/builds/unix/Jamrules.in
@@ -1,2 +1,2 @@
 # final binary installation directory
-BINDIR = @my_bindir@ ;
+BINDIR ?= @my_bindir@ ;
--- ftjam-2.5.2.orig/jamgramtab.h
+++ ftjam-2.5.2/jamgramtab.h
@@ -1,24 +1,20 @@
+	{ "!", _BANG_t },
+	{ "!=", _BANG_EQUALS_t },
+	{ "&", _AMPER_t },
+	{ "&&", _AMPERAMPER_t },
+	{ "(", _LPAREN_t },
+	{ ")", _RPAREN_t },
+	{ "+=", _PLUS_EQUALS_t },
+	{ ":", _COLON_t },
+	{ ";", _SEMIC_t },
 	{ "<", _LANGLE_t },
 	{ "<=", _LANGLE_EQUALS_t },
 	{ "=", _EQUALS_t },
 	{ ">", _RANGLE_t },
 	{ ">=", _RANGLE_EQUALS_t },
-	{ "|", _BAR_t },
-	{ "||", _BARBAR_t },
-	{ ";", _SEMIC_t },
-	{ ":", _COLON_t },
-	{ "!", _BANG_t },
-	{ "!=", _BANG_EQUALS_t },
 	{ "?=", _QUESTION_EQUALS_t },
-	{ "(", _LPAREN_t },
-	{ ")", _RPAREN_t },
 	{ "[", _LBRACKET_t },
 	{ "]", _RBRACKET_t },
-	{ "{", _LBRACE_t },
-	{ "}", _RBRACE_t },
-	{ "&", _AMPER_t },
-	{ "&&", _AMPERAMPER_t },
-	{ "+=", _PLUS_EQUALS_t },
 	{ "actions", ACTIONS_t },
 	{ "bind", BIND_t },
 	{ "break", BREAK_t },
@@ -43,3 +39,7 @@
 	{ "together", TOGETHER_t },
 	{ "updated", UPDATED_t },
 	{ "while", WHILE_t },
+	{ "{", _LBRACE_t },
+	{ "|", _BAR_t },
+	{ "||", _BARBAR_t },
+	{ "}", _RBRACE_t },
--- ftjam-2.5.2.orig/Makefile
+++ ftjam-2.5.2/Makefile
@@ -12,7 +12,7 @@
 
 CC      = gcc
 TARGET  = -o jam0
-CFLAGS  = -g -O2 
+CFLAGS  = -g -O2 -fno-strict-aliasing
 
 all: jam0
 	chmod a+w jambase.c
--- ftjam-2.5.2.orig/Jambase
+++ ftjam-2.5.2/Jambase
@@ -847,7 +847,7 @@
     CRELIB      ?= ;
     DOT     ?= . ;
     DOTDOT      ?= .. ;
-    EXEMODE     ?= 711 ;
+    EXEMODE     ?= 755 ;
     FILEMODE    ?= 644 ;
     FORTRAN     ?= f77 ;
     FORTRANFLAGS    ?= ;
@@ -1963,7 +1963,7 @@
 
 rule Setuid
 {
-    MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4711 ;
+    MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4755 ;
 }
 
 rule Shell
@@ -2259,7 +2259,7 @@
 
 rule UserObject
 {
-    Exit "Unknown suffix on" $(>) "- see UserObject rule in Jamfile(5)." ;
+    Exit "Unknown suffix on" $(>) "- see UserObject rule in /usr/share/doc/ftjam/Jamfile.html." ;
 }
 
 rule Yacc
--- ftjam-2.5.2.orig/Jam.html
+++ ftjam-2.5.2/Jam.html
@@ -169,11 +169,16 @@
 	In the parsing phase, <b>jam</b> reads and executes the Jambase
 	file, by default the built-in one.  It is written in the <b>jam</b>
 	language.  See <a href="#language"> Language</a> below.  The
-	last action of the Jambase is to read (via the "include" rule)
+	last action of the builtin Jambase is to read (via the "include" rule)
 	a user-provided file called "Jamfile".
 
 	<P>
 
+	On Debian systems, the builtin Jambase is available for
+	reference as <tt>/usr/share/doc/ftjam/Jambase.gz</tt>.
+
+	<P>
+
 	Collectively, the purpose of the Jambase and the Jamfile is to
 	name built target and source files, construct the dependency
 	graph among them, and associate build actions with targets.
@@ -273,7 +278,7 @@
 
 <DT> <P> <H3> Overview </H3> <DD>
 
-	<B>Jam</b> has a interpreted, procedural language with a few
+	<B>Jam</b> has an interpreted, procedural language with a few
 	select features to effect program construction.  Statements in
 	<b>jam</b> are rule (procedure) definitions, rule invocations,
 	updating action definitions, flow-of-control structures, variable
@@ -339,7 +344,7 @@
 
 	<P>
 
-	When an rule with updating actions is invoked, those actions are
+	When a rule with updating actions is invoked, those actions are
 	added to those associated with its built targets ($(1)) before
 	the rule's procedure is run.  Later, to build the targets in the
 	updating phase, the actions are passed to the OS command shell,
@@ -365,7 +370,7 @@
 	    <P><DD> Invoke a rule.  A rule is invoked with values in
 	    <I>field1</I> through <I>fieldN</I> (9 max).  They may be
 	    referenced in the procedure's <I>statements</I> as $(1)
-	    through $(<9>N</I>).  $(&lt;) and $(&gt;) are synonymous
+	    through $(<I>N</I>).  $(&lt;) and $(&gt;) are synonymous
 	    with $(1) and $(2).
 
 	<P>
@@ -851,7 +856,7 @@
 
 	<DD> Builds a direct dependency: makes each of <I>targets1</I>
 	depend on each of <I>targets2</I>.  Generally, <I>targets1</I>
-	will be rebuilt if <I>targets2</I> are themselves rebuilt are
+	will be rebuilt if <I>targets2</I> are themselves rebuilt
 	or are newer than <I>targets1</I>.
 
 	<P><DT><CODE>
--- ftjam-2.5.2.orig/jamgram.c
+++ ftjam-2.5.2/jamgram.c
@@ -1,932 +1,2001 @@
-#ifndef lint
-static char const 
-yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
-#endif
-#include <stdlib.h>
-#define YYBYACC 1
-#define YYMAJOR 1
-#define YYMINOR 9
-#define YYLEX yylex()
-#define YYEMPTY -1
-#define yyclearin (yychar=(YYEMPTY))
-#define yyerrok (yyerrflag=0)
-#define YYRECOVERING() (yyerrflag!=0)
-static int yygrowstack();
-#define YYPREFIX "yy"
-#line 84 "jamgram.y"
-
-#include "jam.h"
-
-#include "lists.h"
-#include "variable.h"
-#include "parse.h"
-#include "scan.h"
-#include "compile.h"
-#include "newstr.h"
-#include "rules.h"
-
-# define YYMAXDEPTH 10000	/* for OSF and other less endowed yaccs */
-
-# define F0 (LIST *(*)(PARSE *, LOL *, int *))0
-# define P0 (PARSE *)0
-# define S0 (char *)0
-
-# define pappend( l,r )    	parse_make( compile_append,l,r,P0,S0,S0,0 )
-# define pbreak( l,f )     	parse_make( compile_break,l,P0,P0,S0,S0,f )
-# define peval( c,l,r )		parse_make( compile_eval,l,r,P0,S0,S0,c )
-# define pfor( s,l,r )    	parse_make( compile_foreach,l,r,P0,s,S0,0 )
-# define pif( l,r,t )	  	parse_make( compile_if,l,r,t,S0,S0,0 )
-# define pincl( l )       	parse_make( compile_include,l,P0,P0,S0,S0,0 )
-# define plist( s )	  	parse_make( compile_list,P0,P0,P0,s,S0,0 )
-# define plocal( l,r,t )  	parse_make( compile_local,l,r,t,S0,S0,0 )
-# define pnull()	  	parse_make( compile_null,P0,P0,P0,S0,S0,0 )
-# define pon( l,r )	  	parse_make( compile_on,l,r,P0,S0,S0,0 )
-# define prule( a,p )     	parse_make( compile_rule,a,p,P0,S0,S0,0 )
-# define prules( l,r )	  	parse_make( compile_rules,l,r,P0,S0,S0,0 )
-# define pset( l,r,a ) 	  	parse_make( compile_set,l,r,P0,S0,S0,a )
-# define pset1( l,r,t,a )	parse_make( compile_settings,l,r,t,S0,S0,a )
-# define psetc( s,l,r )     	parse_make( compile_setcomp,l,r,P0,s,S0,0 )
-# define psete( s,l,s1,f ) 	parse_make( compile_setexec,l,P0,P0,s,s1,f )
-# define pswitch( l,r )   	parse_make( compile_switch,l,r,P0,S0,S0,0 )
-# define pwhile( l,r )   	parse_make( compile_while,l,r,P0,S0,S0,0 )
-
-# define pnode( l,r )    	parse_make( F0,l,r,P0,S0,S0,0 )
-# define psnode( s,l )     	parse_make( F0,l,P0,P0,s,S0,0 )
-
-#line 57 "y.tab.c"
-#define YYERRCODE 256
-#define _LANGLE_t 257
-#define _LANGLE_EQUALS_t 258
-#define _EQUALS_t 259
-#define _RANGLE_t 260
-#define _RANGLE_EQUALS_t 261
-#define _BAR_t 262
-#define _BARBAR_t 263
-#define _SEMIC_t 264
+/* A Bison parser, made by GNU Bison 2.1.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Written by Richard Stallman by simplifying the original so called
+   ``semantic'' parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     _BANG_t = 258,
+     _BANG_EQUALS_t = 259,
+     _AMPER_t = 260,
+     _AMPERAMPER_t = 261,
+     _LPAREN_t = 262,
+     _RPAREN_t = 263,
+     _PLUS_EQUALS_t = 264,
+     _COLON_t = 265,
+     _SEMIC_t = 266,
+     _LANGLE_t = 267,
+     _LANGLE_EQUALS_t = 268,
+     _EQUALS_t = 269,
+     _RANGLE_t = 270,
+     _RANGLE_EQUALS_t = 271,
+     _QUESTION_EQUALS_t = 272,
+     _LBRACKET_t = 273,
+     _RBRACKET_t = 274,
+     ACTIONS_t = 275,
+     BIND_t = 276,
+     BREAK_t = 277,
+     CASE_t = 278,
+     CONTINUE_t = 279,
+     DEFAULT_t = 280,
+     ELSE_t = 281,
+     EXISTING_t = 282,
+     FOR_t = 283,
+     IF_t = 284,
+     IGNORE_t = 285,
+     IN_t = 286,
+     INCLUDE_t = 287,
+     LOCAL_t = 288,
+     MAXLINE_t = 289,
+     ON_t = 290,
+     PIECEMEAL_t = 291,
+     QUIETLY_t = 292,
+     RETURN_t = 293,
+     RULE_t = 294,
+     SWITCH_t = 295,
+     TOGETHER_t = 296,
+     UPDATED_t = 297,
+     WHILE_t = 298,
+     _LBRACE_t = 299,
+     _BAR_t = 300,
+     _BARBAR_t = 301,
+     _RBRACE_t = 302,
+     ARG = 303,
+     STRING = 304
+   };
+#endif
+/* Tokens.  */
+#define _BANG_t 258
+#define _BANG_EQUALS_t 259
+#define _AMPER_t 260
+#define _AMPERAMPER_t 261
+#define _LPAREN_t 262
+#define _RPAREN_t 263
+#define _PLUS_EQUALS_t 264
 #define _COLON_t 265
-#define _BANG_t 266
-#define _BANG_EQUALS_t 267
-#define _QUESTION_EQUALS_t 268
-#define _LPAREN_t 269
-#define _RPAREN_t 270
-#define _LBRACKET_t 271
-#define _RBRACKET_t 272
-#define _LBRACE_t 273
-#define _RBRACE_t 274
-#define _AMPER_t 275
-#define _AMPERAMPER_t 276
-#define _PLUS_EQUALS_t 277
-#define ACTIONS_t 278
-#define BIND_t 279
-#define BREAK_t 280
-#define CASE_t 281
-#define CONTINUE_t 282
-#define DEFAULT_t 283
-#define ELSE_t 284
-#define EXISTING_t 285
-#define FOR_t 286
-#define IF_t 287
-#define IGNORE_t 288
-#define IN_t 289
-#define INCLUDE_t 290
-#define LOCAL_t 291
-#define MAXLINE_t 292
-#define ON_t 293
-#define PIECEMEAL_t 294
-#define QUIETLY_t 295
-#define RETURN_t 296
-#define RULE_t 297
-#define SWITCH_t 298
-#define TOGETHER_t 299
-#define UPDATED_t 300
-#define WHILE_t 301
-#define ARG 302
-#define STRING 303
-const short yylhs[] = {                                        -1,
-    0,    0,    2,    2,    1,    1,    1,    1,    3,    3,
-    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-    3,    3,    3,   13,   14,    3,    7,    7,    7,    7,
-    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
-    9,    9,    9,    9,    8,    8,   15,   10,   10,   10,
-    6,    6,    4,   16,   16,    5,   18,    5,   17,   17,
-   17,   11,   11,   19,   19,   19,   19,   19,   19,   19,
-   12,   12,
-};
-const short yylen[] = {                                         2,
-    0,    1,    0,    1,    1,    2,    4,    6,    3,    3,
-    3,    4,    6,    3,    3,    3,    7,    5,    5,    7,
-    5,    6,    3,    0,    0,    9,    1,    1,    1,    2,
-    1,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-    3,    3,    2,    3,    0,    2,    4,    0,    3,    1,
-    1,    3,    1,    0,    2,    1,    0,    4,    2,    4,
-    4,    0,    2,    1,    1,    1,    1,    1,    1,    2,
-    0,    2,
-};
-const short yydefred[] = {                                      0,
-   57,    0,   62,   54,   54,    0,    0,   54,   54,    0,
-   54,    0,   54,    0,   56,    0,    2,    0,    0,    0,
-    4,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    6,   27,
-   29,   28,    0,   54,    0,    0,   54,    0,   54,    0,
-    9,   69,   66,    0,   68,   67,   65,   64,    0,   63,
-   14,   55,   15,   54,   43,    0,   54,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,   10,   54,
-    0,   23,   16,    0,    0,    0,    0,   30,    0,   54,
-   11,    0,    0,   59,   58,   70,   54,    0,    0,   44,
-   42,   34,   35,    0,   36,   37,    0,    0,    0,    0,
-    0,    0,    0,    7,    0,    0,    0,    0,    0,    0,
-   54,   52,   12,   54,   54,   72,   24,    0,    0,    0,
-   49,    0,    0,   18,   46,   21,    0,   61,   60,    0,
-    0,    0,    8,   22,    0,   13,   25,   17,   20,   47,
-    0,   26,
-};
-const short yydgoto[] = {                                      16,
-   21,   22,   18,   45,   30,   46,   47,  118,   31,   85,
-   23,   98,  140,  151,  119,   25,   50,   20,   60,
-};
-const short yysindex[] = {                                   -134,
-    0, -134,    0,    0,    0, -294, -260,    0,    0, -253,
-    0, -288,    0, -260,    0,    0,    0, -134, -214, -261,
-    0, -240, -198, -218, -253, -206, -239, -260, -260, -228,
-   -9, -197, -199, -102, -191, -238, -193,   47,    0,    0,
-    0,    0, -177,    0, -181, -179,    0, -253,    0, -183,
-    0,    0,    0, -209,    0,    0,    0,    0, -184,    0,
-    0,    0,    0,    0,    0,   67,    0, -260, -260, -260,
- -260, -260, -260, -260, -260, -134, -260, -260,    0,    0,
- -134,    0,    0, -166, -173, -178, -134,    0, -200,    0,
-    0, -158, -245,    0,    0,    0,    0, -164, -155,    0,
-    0,    0,    0,  -71,    0,    0, -133, -133,  -71, -167,
-    2,    2, -142,    0, -238, -134, -162, -151, -178, -138,
-    0,    0,    0,    0,    0,    0,    0, -134, -139, -134,
-    0, -125, -114,    0,    0,    0, -110,    0,    0, -148,
- -116, -102,    0,    0, -134,    0,    0,    0,    0,    0,
- -113,    0,
-};
-const short yyrindex[] = {                                    160,
-    0, -109,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    3, -236,    0,
-    0,    0,    0,    0,  -56,    0,    0,    0,    0,  -29,
-    0,    0,    0,    0,    0, -107,    0,    0,    0,    0,
-    0,    0,    0,    0, -224,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0, -103,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0, -109,    0,    0,    0,    0,
-    4,    0,    0, -101,    0, -100, -109,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,   77,    0,    0, -226, -132,   92,    0,
-  101,  110,    0,    0, -107, -109,    0,    0, -100,    0,
-    0,    0,    0,    0,    0,    0,    0, -109,    1,    4,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0, -250,    0,    0,    0,    0,    0,
-    0,    0,
-};
-const short yygindex[] = {                                      0,
-   20,  -54,  -34,    8,    5,  -47,   84,   56,   42,   62,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,
-};
-#define YYTABLESIZE 386
-const short yytable[] = {                                      82,
-   19,   94,    5,    3,   19,   28,   19,   27,   29,    1,
-    1,   24,   26,   36,   34,   32,   33,    1,   35,   17,
-   37,  110,   19,    3,   49,    1,  114,   54,   54,   62,
-    3,   48,  120,   51,   54,   40,   40,   39,   19,   51,
-   15,   15,  122,   40,   40,   61,   40,   51,   15,   64,
-  124,   89,   93,   41,   92,   38,   15,   63,   40,   80,
-   67,  132,   42,   84,   81,   54,   79,   41,   43,   65,
-   66,   99,   83,  141,  101,  143,   42,  139,   44,   86,
-   19,   88,   43,   90,   91,   19,   52,  113,   95,   53,
-  150,   19,   96,   54,   97,   55,   56,  125,  115,  116,
-   57,   58,  117,   59,  126,  123,  129,  149,  127,  102,
-  103,  104,  105,  106,  107,  108,  109,  128,  111,  112,
-   19,  130,  134,   68,   69,   70,   71,   72,  137,   41,
-   41,  138,   19,   75,   19,  136,    1,   41,    2,  133,
-   41,   77,   78,    3,  142,    4,   19,    5,  144,   19,
-  145,    6,    7,  146,  147,    8,    9,  148,   10,    1,
-  152,   11,   12,   13,    3,   48,   14,   15,    1,   71,
-    2,   50,  121,   45,  135,    3,  131,    4,    0,    5,
-    0,    0,    0,    6,    7,   68,   69,    8,   71,   72,
-   10,    0,    0,   11,   12,   13,    0,    0,   14,   15,
-   53,   53,   53,   53,   53,   53,   53,   53,   53,    0,
-   53,   53,    0,   53,    0,   53,   53,    0,   53,   53,
-   53,    0,    0,    0,    0,    0,   53,   31,   31,   31,
-   31,   31,   31,   31,    0,    0,    0,   31,    0,    0,
-   31,    0,    0,   31,    0,   31,   31,   68,   69,   70,
-   71,   72,   73,   74,    0,    0,    0,   75,   68,   69,
-   70,   71,   72,   76,    0,   77,   78,    0,   75,    0,
-    0,   19,    0,   19,   19,    0,    5,    3,   19,    0,
-   19,   19,   19,    5,    3,    0,   19,   19,    0,    0,
-   19,   19,    0,   19,    0,    0,   19,   19,   19,    0,
-    0,   19,   19,   68,   69,   70,   71,   72,   73,   74,
-    0,    0,    0,   75,    0,    0,    0,    0,    0,   87,
-    0,   77,   78,   68,   69,   70,   71,   72,   73,   74,
-    0,    0,    0,   75,    0,   32,  100,    0,   32,   32,
-    0,   77,   78,   32,    0,    0,   32,    0,    0,   32,
-   33,   32,   32,   33,   33,    0,    0,    0,   33,    0,
-    0,   33,   38,   38,   33,    0,   33,   33,    0,    0,
-   38,   39,   39,   38,    0,   38,   38,    0,    0,   39,
-    0,    0,   39,    0,   39,   39,
-};
-const short yycheck[] = {                                      34,
-    0,   49,    0,    0,    0,  266,    2,  302,  269,  271,
-  271,    4,    5,  302,   10,    8,    9,  271,   11,    0,
-   13,   76,   18,  274,   20,  271,   81,  264,  265,   25,
-  281,  293,   87,  274,  271,  262,  263,   18,   34,  264,
-  302,  302,   90,  270,  259,  264,  273,  272,  302,  289,
-  296,   44,   48,  268,   47,   14,  302,  264,  259,  259,
-  289,  116,  277,  302,  264,  302,  264,  268,  283,   28,
-   29,   64,  264,  128,   67,  130,  277,  125,  293,  273,
-   76,  259,  283,  265,  264,   81,  285,   80,  272,  288,
-  145,   87,  302,  292,  279,  294,  295,   93,  265,  273,
-  299,  300,  281,  302,   97,  264,  274,  142,  273,   68,
-   69,   70,   71,   72,   73,   74,   75,  273,   77,   78,
-  116,  264,  274,  257,  258,  259,  260,  261,  121,  262,
-  263,  124,  128,  267,  130,  274,  271,  270,  273,  302,
-  273,  275,  276,  278,  284,  280,  142,  282,  274,  145,
-  265,  286,  287,  264,  303,  290,  291,  274,  293,    0,
-  274,  296,  297,  298,  274,  273,  301,  302,  271,  273,
-  273,  273,   89,  274,  119,  278,  115,  280,   -1,  282,
-   -1,   -1,   -1,  286,  287,  257,  258,  290,  260,  261,
-  293,   -1,   -1,  296,  297,  298,   -1,   -1,  301,  302,
-  257,  258,  259,  260,  261,  262,  263,  264,  265,   -1,
-  267,  268,   -1,  270,   -1,  272,  273,   -1,  275,  276,
-  277,   -1,   -1,   -1,   -1,   -1,  283,  257,  258,  259,
-  260,  261,  262,  263,   -1,   -1,   -1,  267,   -1,   -1,
-  270,   -1,   -1,  273,   -1,  275,  276,  257,  258,  259,
-  260,  261,  262,  263,   -1,   -1,   -1,  267,  257,  258,
-  259,  260,  261,  273,   -1,  275,  276,   -1,  267,   -1,
-   -1,  271,   -1,  273,  274,   -1,  274,  274,  278,   -1,
-  280,  281,  282,  281,  281,   -1,  286,  287,   -1,   -1,
-  290,  291,   -1,  293,   -1,   -1,  296,  297,  298,   -1,
-   -1,  301,  302,  257,  258,  259,  260,  261,  262,  263,
-   -1,   -1,   -1,  267,   -1,   -1,   -1,   -1,   -1,  273,
-   -1,  275,  276,  257,  258,  259,  260,  261,  262,  263,
-   -1,   -1,   -1,  267,   -1,  259,  270,   -1,  262,  263,
-   -1,  275,  276,  267,   -1,   -1,  270,   -1,   -1,  273,
-  259,  275,  276,  262,  263,   -1,   -1,   -1,  267,   -1,
-   -1,  270,  262,  263,  273,   -1,  275,  276,   -1,   -1,
-  270,  262,  263,  273,   -1,  275,  276,   -1,   -1,  270,
-   -1,   -1,  273,   -1,  275,  276,
-};
-#define YYFINAL 16
+#define _SEMIC_t 266
+#define _LANGLE_t 267
+#define _LANGLE_EQUALS_t 268
+#define _EQUALS_t 269
+#define _RANGLE_t 270
+#define _RANGLE_EQUALS_t 271
+#define _QUESTION_EQUALS_t 272
+#define _LBRACKET_t 273
+#define _RBRACKET_t 274
+#define ACTIONS_t 275
+#define BIND_t 276
+#define BREAK_t 277
+#define CASE_t 278
+#define CONTINUE_t 279
+#define DEFAULT_t 280
+#define ELSE_t 281
+#define EXISTING_t 282
+#define FOR_t 283
+#define IF_t 284
+#define IGNORE_t 285
+#define IN_t 286
+#define INCLUDE_t 287
+#define LOCAL_t 288
+#define MAXLINE_t 289
+#define ON_t 290
+#define PIECEMEAL_t 291
+#define QUIETLY_t 292
+#define RETURN_t 293
+#define RULE_t 294
+#define SWITCH_t 295
+#define TOGETHER_t 296
+#define UPDATED_t 297
+#define WHILE_t 298
+#define _LBRACE_t 299
+#define _BAR_t 300
+#define _BARBAR_t 301
+#define _RBRACE_t 302
+#define ARG 303
+#define STRING 304
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 84 "jamgram.y"
+
+#include "jam.h"
+
+#include "lists.h"
+#include "variable.h"
+#include "parse.h"
+#include "scan.h"
+#include "compile.h"
+#include "newstr.h"
+#include "rules.h"
+
+# define YYMAXDEPTH 10000	/* for OSF and other less endowed yaccs */
+
+# define F0 (LIST *(*)(PARSE *, LOL *, int *))0
+# define P0 (PARSE *)0
+# define S0 (char *)0
+
+# define pappend( l,r )    	parse_make( compile_append,l,r,P0,S0,S0,0 )
+# define pbreak( l,f )     	parse_make( compile_break,l,P0,P0,S0,S0,f )
+# define peval( c,l,r )		parse_make( compile_eval,l,r,P0,S0,S0,c )
+# define pfor( s,l,r )    	parse_make( compile_foreach,l,r,P0,s,S0,0 )
+# define pif( l,r,t )	  	parse_make( compile_if,l,r,t,S0,S0,0 )
+# define pincl( l )       	parse_make( compile_include,l,P0,P0,S0,S0,0 )
+# define plist( s )	  	parse_make( compile_list,P0,P0,P0,s,S0,0 )
+# define plocal( l,r,t )  	parse_make( compile_local,l,r,t,S0,S0,0 )
+# define pnull()	  	parse_make( compile_null,P0,P0,P0,S0,S0,0 )
+# define pon( l,r )	  	parse_make( compile_on,l,r,P0,S0,S0,0 )
+# define prule( a,p )     	parse_make( compile_rule,a,p,P0,S0,S0,0 )
+# define prules( l,r )	  	parse_make( compile_rules,l,r,P0,S0,S0,0 )
+# define pset( l,r,a ) 	  	parse_make( compile_set,l,r,P0,S0,S0,a )
+# define pset1( l,r,t,a )	parse_make( compile_settings,l,r,t,S0,S0,a )
+# define psetc( s,l,r )     	parse_make( compile_setcomp,l,r,P0,s,S0,0 )
+# define psete( s,l,s1,f ) 	parse_make( compile_setexec,l,P0,P0,s,s1,f )
+# define pswitch( l,r )   	parse_make( compile_switch,l,r,P0,S0,S0,0 )
+# define pwhile( l,r )   	parse_make( compile_while,l,r,P0,S0,S0,0 )
+
+# define pnode( l,r )    	parse_make( F0,l,r,P0,S0,S0,0 )
+# define psnode( s,l )     	parse_make( F0,l,P0,P0,s,S0,0 )
+
+
+
+/* Enabling traces.  */
 #ifndef YYDEBUG
-#define YYDEBUG 0
+# define YYDEBUG 0
 #endif
-#define YYMAXTOKEN 303
-#if YYDEBUG
-const char * const yyname[] = {
-"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"_LANGLE_t","_LANGLE_EQUALS_t",
-"_EQUALS_t","_RANGLE_t","_RANGLE_EQUALS_t","_BAR_t","_BARBAR_t","_SEMIC_t",
-"_COLON_t","_BANG_t","_BANG_EQUALS_t","_QUESTION_EQUALS_t","_LPAREN_t",
-"_RPAREN_t","_LBRACKET_t","_RBRACKET_t","_LBRACE_t","_RBRACE_t","_AMPER_t",
-"_AMPERAMPER_t","_PLUS_EQUALS_t","ACTIONS_t","BIND_t","BREAK_t","CASE_t",
-"CONTINUE_t","DEFAULT_t","ELSE_t","EXISTING_t","FOR_t","IF_t","IGNORE_t","IN_t",
-"INCLUDE_t","LOCAL_t","MAXLINE_t","ON_t","PIECEMEAL_t","QUIETLY_t","RETURN_t",
-"RULE_t","SWITCH_t","TOGETHER_t","UPDATED_t","WHILE_t","ARG","STRING",
-};
-const char * const yyrule[] = {
-"$accept : run",
-"run :",
-"run : rules",
-"block :",
-"block : rules",
-"rules : rule",
-"rules : rule rules",
-"rules : LOCAL_t list _SEMIC_t block",
-"rules : LOCAL_t list _EQUALS_t list _SEMIC_t block",
-"rule : _LBRACE_t block _RBRACE_t",
-"rule : INCLUDE_t list _SEMIC_t",
-"rule : arg lol _SEMIC_t",
-"rule : arg assign list _SEMIC_t",
-"rule : arg ON_t list assign list _SEMIC_t",
-"rule : BREAK_t list _SEMIC_t",
-"rule : CONTINUE_t list _SEMIC_t",
-"rule : RETURN_t list _SEMIC_t",
-"rule : FOR_t ARG IN_t list _LBRACE_t block _RBRACE_t",
-"rule : SWITCH_t list _LBRACE_t cases _RBRACE_t",
-"rule : IF_t expr _LBRACE_t block _RBRACE_t",
-"rule : IF_t expr _LBRACE_t block _RBRACE_t ELSE_t rule",
-"rule : WHILE_t expr _LBRACE_t block _RBRACE_t",
-"rule : RULE_t ARG params _LBRACE_t block _RBRACE_t",
-"rule : ON_t arg rule",
-"$$1 :",
-"$$2 :",
-"rule : ACTIONS_t eflags ARG bindlist _LBRACE_t $$1 STRING $$2 _RBRACE_t",
-"assign : _EQUALS_t",
-"assign : _PLUS_EQUALS_t",
-"assign : _QUESTION_EQUALS_t",
-"assign : DEFAULT_t _EQUALS_t",
-"expr : arg",
-"expr : expr _EQUALS_t expr",
-"expr : expr _BANG_EQUALS_t expr",
-"expr : expr _LANGLE_t expr",
-"expr : expr _LANGLE_EQUALS_t expr",
-"expr : expr _RANGLE_t expr",
-"expr : expr _RANGLE_EQUALS_t expr",
-"expr : expr _AMPER_t expr",
-"expr : expr _AMPERAMPER_t expr",
-"expr : expr _BAR_t expr",
-"expr : expr _BARBAR_t expr",
-"expr : arg IN_t list",
-"expr : _BANG_t expr",
-"expr : _LPAREN_t expr _RPAREN_t",
-"cases :",
-"cases : case cases",
-"case : CASE_t ARG _COLON_t block",
-"params :",
-"params : ARG _COLON_t params",
-"params : ARG",
-"lol : list",
-"lol : list _COLON_t lol",
-"list : listp",
-"listp :",
-"listp : listp arg",
-"arg : ARG",
-"$$3 :",
-"arg : _LBRACKET_t $$3 func _RBRACKET_t",
-"func : arg lol",
-"func : ON_t arg arg lol",
-"func : ON_t arg RETURN_t list",
-"eflags :",
-"eflags : eflags eflag",
-"eflag : UPDATED_t",
-"eflag : TOGETHER_t",
-"eflag : IGNORE_t",
-"eflag : QUIETLY_t",
-"eflag : PIECEMEAL_t",
-"eflag : EXISTING_t",
-"eflag : MAXLINE_t ARG",
-"bindlist :",
-"bindlist : BIND_t list",
-};
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
 #endif
-#ifndef YYSTYPE
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
 typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 219 of yacc.c.  */
+#line 235 "y.tab.c"
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T) && (defined (__STDC__) || defined (__cplusplus))
+# include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+#if ! defined (yyoverflow) || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if defined (__STDC__) || defined (__cplusplus)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     define YYINCLUDED_STDLIB_H
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2005 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM ((YYSIZE_T) -1)
+#  endif
+#  ifdef __cplusplus
+extern "C" {
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if (! defined (malloc) && ! defined (YYINCLUDED_STDLIB_H) \
+	&& (defined (__STDC__) || defined (__cplusplus)))
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if (! defined (free) && ! defined (YYINCLUDED_STDLIB_H) \
+	&& (defined (__STDC__) || defined (__cplusplus)))
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifdef __cplusplus
+}
+#  endif
+# endif
+#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short int yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short int) + sizeof (YYSTYPE))			\
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined (__GNUC__) && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
+
+#endif
+
+#if defined (__STDC__) || defined (__cplusplus)
+   typedef signed char yysigned_char;
+#else
+   typedef short int yysigned_char;
 #endif
+
+/* YYFINAL -- State number of the termination state. */
+#define YYFINAL  39
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   255
+
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  50
+/* YYNNTS -- Number of nonterminals. */
+#define YYNNTS  21
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  73
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  154
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   304
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const unsigned char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49
+};
+
 #if YYDEBUG
-#include <stdio.h>
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const unsigned char yyprhs[] =
+{
+       0,     0,     3,     4,     6,     7,     9,    11,    14,    19,
+      26,    30,    34,    38,    43,    50,    54,    58,    62,    70,
+      76,    82,    90,    96,   103,   107,   108,   109,   119,   121,
+     123,   125,   128,   130,   134,   138,   142,   146,   150,   154,
+     158,   162,   166,   170,   174,   177,   181,   182,   185,   190,
+     191,   195,   197,   199,   203,   205,   206,   209,   211,   212,
+     217,   220,   225,   230,   231,   234,   236,   238,   240,   242,
+     244,   246,   249,   250
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const yysigned_char yyrhs[] =
+{
+      51,     0,    -1,    -1,    53,    -1,    -1,    53,    -1,    54,
+      -1,    54,    53,    -1,    33,    63,    11,    52,    -1,    33,
+      63,    14,    63,    11,    52,    -1,    44,    52,    47,    -1,
+      32,    63,    11,    -1,    65,    62,    11,    -1,    65,    57,
+      63,    11,    -1,    65,    35,    63,    57,    63,    11,    -1,
+      22,    63,    11,    -1,    24,    63,    11,    -1,    38,    63,
+      11,    -1,    28,    48,    31,    63,    44,    52,    47,    -1,
+      40,    63,    44,    59,    47,    -1,    29,    58,    44,    52,
+      47,    -1,    29,    58,    44,    52,    47,    26,    54,    -1,
+      43,    58,    44,    52,    47,    -1,    39,    48,    61,    44,
+      52,    47,    -1,    35,    65,    54,    -1,    -1,    -1,    20,
+      68,    48,    70,    44,    55,    49,    56,    47,    -1,    14,
+      -1,     9,    -1,    17,    -1,    25,    14,    -1,    65,    -1,
+      58,    14,    58,    -1,    58,     4,    58,    -1,    58,    12,
+      58,    -1,    58,    13,    58,    -1,    58,    15,    58,    -1,
+      58,    16,    58,    -1,    58,     5,    58,    -1,    58,     6,
+      58,    -1,    58,    45,    58,    -1,    58,    46,    58,    -1,
+      65,    31,    63,    -1,     3,    58,    -1,     7,    58,     8,
+      -1,    -1,    60,    59,    -1,    23,    48,    10,    52,    -1,
+      -1,    48,    10,    61,    -1,    48,    -1,    63,    -1,    63,
+      10,    62,    -1,    64,    -1,    -1,    64,    65,    -1,    48,
+      -1,    -1,    18,    66,    67,    19,    -1,    65,    62,    -1,
+      35,    65,    65,    62,    -1,    35,    65,    38,    63,    -1,
+      -1,    68,    69,    -1,    42,    -1,    41,    -1,    30,    -1,
+      37,    -1,    36,    -1,    27,    -1,    34,    48,    -1,    -1,
+      21,    63,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const unsigned short int yyrline[] =
+{
+       0,   127,   127,   129,   141,   142,   146,   148,   150,   152,
+     156,   158,   160,   162,   164,   166,   168,   170,   172,   174,
+     176,   178,   180,   182,   184,   187,   189,   186,   198,   200,
+     202,   204,   212,   214,   216,   218,   220,   222,   224,   226,
+     228,   230,   232,   234,   236,   238,   249,   250,   254,   264,
+     265,   267,   276,   278,   288,   293,   294,   298,   300,   300,
+     309,   311,   313,   323,   324,   328,   330,   332,   334,   336,
+     338,   340,   350,   351
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "_BANG_t", "_BANG_EQUALS_t", "_AMPER_t",
+  "_AMPERAMPER_t", "_LPAREN_t", "_RPAREN_t", "_PLUS_EQUALS_t", "_COLON_t",
+  "_SEMIC_t", "_LANGLE_t", "_LANGLE_EQUALS_t", "_EQUALS_t", "_RANGLE_t",
+  "_RANGLE_EQUALS_t", "_QUESTION_EQUALS_t", "_LBRACKET_t", "_RBRACKET_t",
+  "ACTIONS_t", "BIND_t", "BREAK_t", "CASE_t", "CONTINUE_t", "DEFAULT_t",
+  "ELSE_t", "EXISTING_t", "FOR_t", "IF_t", "IGNORE_t", "IN_t", "INCLUDE_t",
+  "LOCAL_t", "MAXLINE_t", "ON_t", "PIECEMEAL_t", "QUIETLY_t", "RETURN_t",
+  "RULE_t", "SWITCH_t", "TOGETHER_t", "UPDATED_t", "WHILE_t", "_LBRACE_t",
+  "_BAR_t", "_BARBAR_t", "_RBRACE_t", "ARG", "STRING", "$accept", "run",
+  "block", "rules", "rule", "@1", "@2", "assign", "expr", "cases", "case",
+  "params", "lol", "list", "listp", "arg", "@3", "func", "eflags", "eflag",
+  "bindlist", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const unsigned short int yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const unsigned char yyr1[] =
+{
+       0,    50,    51,    51,    52,    52,    53,    53,    53,    53,
+      54,    54,    54,    54,    54,    54,    54,    54,    54,    54,
+      54,    54,    54,    54,    54,    55,    56,    54,    57,    57,
+      57,    57,    58,    58,    58,    58,    58,    58,    58,    58,
+      58,    58,    58,    58,    58,    58,    59,    59,    60,    61,
+      61,    61,    62,    62,    63,    64,    64,    65,    66,    65,
+      67,    67,    67,    68,    68,    69,    69,    69,    69,    69,
+      69,    69,    70,    70
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const unsigned char yyr2[] =
+{
+       0,     2,     0,     1,     0,     1,     1,     2,     4,     6,
+       3,     3,     3,     4,     6,     3,     3,     3,     7,     5,
+       5,     7,     5,     6,     3,     0,     0,     9,     1,     1,
+       1,     2,     1,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     2,     3,     0,     2,     4,     0,
+       3,     1,     1,     3,     1,     0,     2,     1,     0,     4,
+       2,     4,     4,     0,     2,     1,     1,     1,     1,     1,
+       1,     2,     0,     2
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const unsigned char yydefact[] =
+{
+       2,    58,    63,    55,    55,     0,     0,    55,    55,     0,
+      55,     0,    55,     0,     4,    57,     0,     3,     6,    55,
+       0,     0,     0,    54,     0,     0,     0,     0,     0,    32,
+       0,     0,     0,     0,    49,     0,     0,     0,     5,     1,
+       7,    29,    28,    30,     0,    55,    55,     0,    52,     0,
+      55,     0,    70,    67,     0,    69,    68,    66,    65,    72,
+      64,    15,    56,    16,    55,    44,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     4,     0,     0,    55,    11,
+       4,    55,    24,    17,    51,     0,    46,     4,    10,    31,
+       0,     0,    12,    55,     0,    60,    59,    71,    55,     0,
+       0,    45,    34,    39,    40,    35,    36,    33,    37,    38,
+       0,    41,    42,    43,     8,     0,    49,     4,     0,     0,
+      46,     0,    55,    13,    53,    55,    55,    73,    25,     4,
+      20,     4,    50,     0,     0,    19,    47,    22,     0,    62,
+      61,     0,     0,     0,     9,    23,     4,    14,    26,    18,
+      21,    48,     0,    27
+};
+
+/* YYDEFGOTO[NTERM-NUM]. */
+static const short int yydefgoto[] =
+{
+      -1,    16,    37,    38,    18,   141,   152,    46,    28,   119,
+     120,    85,    47,    48,    23,    29,    20,    51,    21,    60,
+      99
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -59
+static const short int yypact[] =
+{
+     154,   -59,   -59,   -59,   -59,   -32,     8,   -59,   -59,    -6,
+     -59,    -7,   -59,     8,   154,   -59,    46,   -59,   154,    49,
+     -14,   200,    37,    -6,    40,    21,     8,     8,   120,    22,
+      43,    19,   185,    58,     9,    26,   135,    25,   -59,   -59,
+     -59,   -59,   -59,   -59,    63,   -59,   -59,    67,    71,    -6,
+     -59,    66,   -59,   -59,    38,   -59,   -59,   -59,   -59,    61,
+     -59,   -59,   -59,   -59,   -59,   -59,   155,     8,     8,     8,
+       8,     8,     8,     8,     8,   154,     8,     8,   -59,   -59,
+     154,   -59,   -59,   -59,    79,    47,    69,   154,   -59,   -59,
+      10,    82,   -59,   -59,     7,   -59,   -59,   -59,   -59,    51,
+      53,   -59,    52,    24,    24,   -59,   -59,    52,   -59,   -59,
+      62,   239,   239,   -59,   -59,    87,     9,   154,    42,    65,
+      69,    68,   -59,   -59,   -59,   -59,   -59,   -59,   -59,   154,
+      73,   154,   -59,    72,    90,   -59,   -59,   -59,   102,   -59,
+     -59,    78,    74,   185,   -59,   -59,   154,   -59,   -59,   -59,
+     -59,   -59,    75,   -59
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yysigned_char yypgoto[] =
+{
+     -59,   -59,   -58,    13,   -29,   -59,   -59,    28,    34,    -4,
+     -59,    12,   -43,    -2,   -59,     0,   -59,   -59,   -59,   -59,
+     -59
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -1
+static const unsigned char yytable[] =
+{
+      19,    22,    24,    82,     1,    30,    31,    95,    33,    32,
+      35,    26,     1,    17,    19,    27,    25,   110,    19,    41,
+      50,    49,   114,    62,    42,     1,     1,    43,    67,   121,
+      80,    40,    19,    81,    15,    44,    70,    71,    72,    73,
+      74,    34,    15,    90,    91,   125,    39,    36,    61,    94,
+     124,    63,    64,    78,    79,    15,    15,    84,    41,   133,
+      65,    66,   100,    42,    70,    71,    43,    73,    74,    83,
+      86,   142,    88,   144,    44,    19,   113,    89,    92,   115,
+      19,    93,    98,   140,    45,    96,    97,    19,   151,   116,
+     134,   117,   118,   123,   126,   128,   127,   129,   131,   143,
+     146,   102,   103,   104,   105,   106,   107,   108,   109,   130,
+     111,   112,   135,   147,   150,   137,   136,    19,   122,   145,
+     138,   149,   153,   139,    67,    68,    69,   148,   132,    19,
+       0,    19,    70,    71,    72,    73,    74,     0,     0,    67,
+      68,    69,     0,    19,     0,     0,    19,    70,    71,    72,
+      73,    74,     0,     0,     0,     0,     0,     0,     0,    67,
+      68,    69,     0,   101,    75,    76,    77,    70,    71,    72,
+      73,    74,     1,     0,     2,     0,     3,     0,     4,    87,
+      76,    77,     5,     6,     0,     0,     7,     8,     0,     9,
+       0,     0,    10,    11,    12,     0,     0,    13,    14,     0,
+      76,    77,    15,     1,     0,     2,     0,     3,     0,     4,
+       0,     0,     0,     5,     6,     0,     0,     7,     0,     0,
+       9,     0,     0,    10,    11,    12,     0,    52,    13,    14,
+      53,     0,     0,    15,    54,     0,    55,    56,     0,     0,
+       0,    57,    58,    67,    68,    69,     0,     0,    59,     0,
+       0,    70,    71,    72,    73,    74
+};
+
+static const short int yycheck[] =
+{
+       0,     3,     4,    32,    18,     7,     8,    50,    10,     9,
+      12,     3,    18,     0,    14,     7,    48,    75,    18,     9,
+      20,    35,    80,    23,    14,    18,    18,    17,     4,    87,
+      11,    18,    32,    14,    48,    25,    12,    13,    14,    15,
+      16,    48,    48,    45,    46,    38,     0,    13,    11,    49,
+      93,    11,    31,    31,    11,    48,    48,    48,     9,   117,
+      26,    27,    64,    14,    12,    13,    17,    15,    16,    11,
+      44,   129,    47,   131,    25,    75,    78,    14,    11,    81,
+      80,    10,    21,   126,    35,    19,    48,    87,   146,    10,
+      48,    44,    23,    11,    94,    44,    98,    44,    11,    26,
+      10,    67,    68,    69,    70,    71,    72,    73,    74,    47,
+      76,    77,    47,    11,   143,    47,   120,   117,    90,    47,
+     122,    47,    47,   125,     4,     5,     6,    49,   116,   129,
+      -1,   131,    12,    13,    14,    15,    16,    -1,    -1,     4,
+       5,     6,    -1,   143,    -1,    -1,   146,    12,    13,    14,
+      15,    16,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     4,
+       5,     6,    -1,     8,    44,    45,    46,    12,    13,    14,
+      15,    16,    18,    -1,    20,    -1,    22,    -1,    24,    44,
+      45,    46,    28,    29,    -1,    -1,    32,    33,    -1,    35,
+      -1,    -1,    38,    39,    40,    -1,    -1,    43,    44,    -1,
+      45,    46,    48,    18,    -1,    20,    -1,    22,    -1,    24,
+      -1,    -1,    -1,    28,    29,    -1,    -1,    32,    -1,    -1,
+      35,    -1,    -1,    38,    39,    40,    -1,    27,    43,    44,
+      30,    -1,    -1,    48,    34,    -1,    36,    37,    -1,    -1,
+      -1,    41,    42,     4,     5,     6,    -1,    -1,    48,    -1,
+      -1,    12,    13,    14,    15,    16
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const unsigned char yystos[] =
+{
+       0,    18,    20,    22,    24,    28,    29,    32,    33,    35,
+      38,    39,    40,    43,    44,    48,    51,    53,    54,    65,
+      66,    68,    63,    64,    63,    48,     3,     7,    58,    65,
+      63,    63,    65,    63,    48,    63,    58,    52,    53,     0,
+      53,     9,    14,    17,    25,    35,    57,    62,    63,    35,
+      65,    67,    27,    30,    34,    36,    37,    41,    42,    48,
+      69,    11,    65,    11,    31,    58,    58,     4,     5,     6,
+      12,    13,    14,    15,    16,    44,    45,    46,    31,    11,
+      11,    14,    54,    11,    48,    61,    44,    44,    47,    14,
+      63,    63,    11,    10,    65,    62,    19,    48,    21,    70,
+      63,     8,    58,    58,    58,    58,    58,    58,    58,    58,
+      52,    58,    58,    63,    52,    63,    10,    44,    23,    59,
+      60,    52,    57,    11,    62,    38,    65,    63,    44,    44,
+      47,    11,    61,    52,    48,    47,    59,    47,    63,    63,
+      62,    55,    52,    26,    52,    47,    10,    11,    49,    47,
+      54,    52,    56,    47
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (0)
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (N)								\
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (0)
 #endif
-#ifdef YYSTACKSIZE
-#undef YYMAXDEPTH
-#define YYMAXDEPTH YYSTACKSIZE
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+              (Loc).first_line, (Loc).first_column,	\
+              (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
 #else
-#ifdef YYMAXDEPTH
-#define YYSTACKSIZE YYMAXDEPTH
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)		\
+do {								\
+  if (yydebug)							\
+    {								\
+      YYFPRINTF (stderr, "%s ", Title);				\
+      yysymprint (stderr,					\
+                  Type, Value);	\
+      YYFPRINTF (stderr, "\n");					\
+    }								\
+} while (0)
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_stack_print (short int *bottom, short int *top)
 #else
-#define YYSTACKSIZE 10000
-#define YYMAXDEPTH 10000
+static void
+yy_stack_print (bottom, top)
+    short int *bottom;
+    short int *top;
 #endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (/* Nothing. */; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_reduce_print (int yyrule)
+#else
+static void
+yy_reduce_print (yyrule)
+    int yyrule;
 #endif
-#define YYINITSTACKSIZE 200
-int yydebug;
-int yynerrs;
-int yyerrflag;
-int yychar;
-short *yyssp;
-YYSTYPE *yyvsp;
-YYSTYPE yyval;
-YYSTYPE yylval;
-short *yyss;
-short *yysslim;
-YYSTYPE *yyvs;
-int yystacksize;
-/* allocate initial stack or double stack size, up to YYMAXDEPTH */
-static int yygrowstack()
-{
-    int newsize, i;
-    short *newss;
-    YYSTYPE *newvs;
-
-    if ((newsize = yystacksize) == 0)
-        newsize = YYINITSTACKSIZE;
-    else if (newsize >= YYMAXDEPTH)
-        return -1;
-    else if ((newsize *= 2) > YYMAXDEPTH)
-        newsize = YYMAXDEPTH;
-    i = yyssp - yyss;
-    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
-      (short *)malloc(newsize * sizeof *newss);
-    if (newss == NULL)
-        return -1;
-    yyss = newss;
-    yyssp = newss + i;
-    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
-      (YYSTYPE *)malloc(newsize * sizeof *newvs);
-    if (newvs == NULL)
-        return -1;
-    yyvs = newvs;
-    yyvsp = newvs + i;
-    yystacksize = newsize;
-    yysslim = yyss + newsize - 1;
-    return 0;
+{
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu), ",
+             yyrule - 1, yylno);
+  /* Print the symbols being reduced, and their result.  */
+  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
+    YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
+  YYFPRINTF (stderr, "-> %s\n", yytname[yyr1[yyrule]]);
 }
 
-#define YYABORT goto yyabort
-#define YYREJECT goto yyabort
-#define YYACCEPT goto yyaccept
-#define YYERROR goto yyerrlab
-
-#ifndef YYPARSE_PARAM
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG void
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif	/* ANSI-C/C++ */
-#else	/* YYPARSE_PARAM */
-#ifndef YYPARSE_PARAM_TYPE
-#define YYPARSE_PARAM_TYPE void *
-#endif
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
-#endif	/* ANSI-C/C++ */
-#endif	/* ! YYPARSE_PARAM */
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (Rule);		\
+} while (0)
 
-int
-yyparse (YYPARSE_PARAM_ARG)
-    YYPARSE_PARAM_DECL
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
 {
-    register int yym, yyn, yystate;
-#if YYDEBUG
-    register const char *yys;
+  const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
 
-    if ((yys = getenv("YYDEBUG")))
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
     {
-        yyn = *yys;
-        if (yyn >= '0' && yyn <= '9')
-            yydebug = yyn - '0';
+      size_t yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
     }
-#endif
 
-    yynerrs = 0;
-    yyerrflag = 0;
-    yychar = (-1);
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
 
-    if (yyss == NULL && yygrowstack()) goto yyoverflow;
-    yyssp = yyss;
-    yyvsp = yyvs;
-    *yyssp = yystate = 0;
+#endif /* YYERROR_VERBOSE */
+
+
 
-yyloop:
-    if ((yyn = yydefred[yystate])) goto yyreduce;
-    if (yychar < 0)
-    {
-        if ((yychar = yylex()) < 0) yychar = 0;
 #if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, reading %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yysymprint (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE *yyvaluep;
 #endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  switch (yytype)
+    {
+      default:
+        break;
     }
-    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+  YYFPRINTF (yyoutput, ")");
+}
+
+#endif /* ! YYDEBUG */
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
     {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: state %d, shifting to state %d\n",
-                    YYPREFIX, yystate, yytable[yyn]);
+
+      default:
+        break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM);
+# else
+int yyparse ();
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void);
+#else
+int yyparse ();
 #endif
-        if (yyssp >= yysslim && yygrowstack())
-        {
-            goto yyoverflow;
-        }
-        *++yyssp = yystate = yytable[yyn];
-        *++yyvsp = yylval;
-        yychar = (-1);
-        if (yyerrflag > 0)  --yyerrflag;
-        goto yyloop;
-    }
-    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
-    {
-        yyn = yytable[yyn];
-        goto yyreduce;
-    }
-    if (yyerrflag) goto yyinrecovery;
-#if defined(lint) || defined(__GNUC__)
-    goto yynewerror;
-#endif
-yynewerror:
-    yyerror("syntax error");
-#if defined(lint) || defined(__GNUC__)
-    goto yyerrlab;
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM)
+# else
+int yyparse (YYPARSE_PARAM)
+  void *YYPARSE_PARAM;
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+    ;
 #endif
-yyerrlab:
-    ++yynerrs;
-yyinrecovery:
-    if (yyerrflag < 3)
+#endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  short int yyssa[YYINITDEPTH];
+  short int *yyss = yyssa;
+  short int *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule.  */
+  int yylen;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
     {
-        yyerrflag = 3;
-        for (;;)
-        {
-            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
-                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: state %d, error recovery shifting\
- to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
-#endif
-                if (yyssp >= yysslim && yygrowstack())
-                {
-                    goto yyoverflow;
-                }
-                *++yyssp = yystate = yytable[yyn];
-                *++yyvsp = yylval;
-                goto yyloop;
-            }
-            else
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: error recovery discarding state %d\n",
-                            YYPREFIX, *yyssp);
-#endif
-                if (yyssp <= yyss) goto yyabort;
-                --yyssp;
-                --yyvsp;
-            }
-        }
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short int *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	short int *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a look-ahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
     }
-    else
+
+  if (yychar <= YYEOF)
     {
-        if (yychar == 0) goto yyabort;
-#if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
-#endif
-        yychar = (-1);
-        goto yyloop;
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
 yyreduce:
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
-                YYPREFIX, yystate, yyn, yyrule[yyn]);
-#endif
-    yym = yylen[yyn];
-    yyval = yyvsp[1-yym];
-    switch (yyn)
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
     {
-case 2:
+        case 3:
 #line 130 "jamgram.y"
-{ parse_save( yyvsp[0].parse ); }
-break;
-case 3:
+    { parse_save( (yyvsp[0]).parse ); }
+    break;
+
+  case 4:
 #line 141 "jamgram.y"
-{ yyval.parse = pnull(); }
-break;
-case 4:
+    { (yyval).parse = pnull(); }
+    break;
+
+  case 5:
 #line 143 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; }
-break;
-case 5:
+    { (yyval).parse = (yyvsp[0]).parse; }
+    break;
+
+  case 6:
 #line 147 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; }
-break;
-case 6:
+    { (yyval).parse = (yyvsp[0]).parse; }
+    break;
+
+  case 7:
 #line 149 "jamgram.y"
-{ yyval.parse = prules( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 7:
+    { (yyval).parse = prules( (yyvsp[-1]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 8:
 #line 151 "jamgram.y"
-{ yyval.parse = plocal( yyvsp[-2].parse, pnull(), yyvsp[0].parse ); }
-break;
-case 8:
+    { (yyval).parse = plocal( (yyvsp[-2]).parse, pnull(), (yyvsp[0]).parse ); }
+    break;
+
+  case 9:
 #line 153 "jamgram.y"
-{ yyval.parse = plocal( yyvsp[-4].parse, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 9:
+    { (yyval).parse = plocal( (yyvsp[-4]).parse, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 10:
 #line 157 "jamgram.y"
-{ yyval.parse = yyvsp[-1].parse; }
-break;
-case 10:
+    { (yyval).parse = (yyvsp[-1]).parse; }
+    break;
+
+  case 11:
 #line 159 "jamgram.y"
-{ yyval.parse = pincl( yyvsp[-1].parse ); }
-break;
-case 11:
+    { (yyval).parse = pincl( (yyvsp[-1]).parse ); }
+    break;
+
+  case 12:
 #line 161 "jamgram.y"
-{ yyval.parse = prule( yyvsp[-2].parse, yyvsp[-1].parse ); }
-break;
-case 12:
+    { (yyval).parse = prule( (yyvsp[-2]).parse, (yyvsp[-1]).parse ); }
+    break;
+
+  case 13:
 #line 163 "jamgram.y"
-{ yyval.parse = pset( yyvsp[-3].parse, yyvsp[-1].parse, yyvsp[-2].number ); }
-break;
-case 13:
+    { (yyval).parse = pset( (yyvsp[-3]).parse, (yyvsp[-1]).parse, (yyvsp[-2]).number ); }
+    break;
+
+  case 14:
 #line 165 "jamgram.y"
-{ yyval.parse = pset1( yyvsp[-5].parse, yyvsp[-3].parse, yyvsp[-1].parse, yyvsp[-2].number ); }
-break;
-case 14:
+    { (yyval).parse = pset1( (yyvsp[-5]).parse, (yyvsp[-3]).parse, (yyvsp[-1]).parse, (yyvsp[-2]).number ); }
+    break;
+
+  case 15:
 #line 167 "jamgram.y"
-{ yyval.parse = pbreak( yyvsp[-1].parse, JMP_BREAK ); }
-break;
-case 15:
+    { (yyval).parse = pbreak( (yyvsp[-1]).parse, JMP_BREAK ); }
+    break;
+
+  case 16:
 #line 169 "jamgram.y"
-{ yyval.parse = pbreak( yyvsp[-1].parse, JMP_CONTINUE ); }
-break;
-case 16:
+    { (yyval).parse = pbreak( (yyvsp[-1]).parse, JMP_CONTINUE ); }
+    break;
+
+  case 17:
 #line 171 "jamgram.y"
-{ yyval.parse = pbreak( yyvsp[-1].parse, JMP_RETURN ); }
-break;
-case 17:
+    { (yyval).parse = pbreak( (yyvsp[-1]).parse, JMP_RETURN ); }
+    break;
+
+  case 18:
 #line 173 "jamgram.y"
-{ yyval.parse = pfor( yyvsp[-5].string, yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 18:
+    { (yyval).parse = pfor( (yyvsp[-5]).string, (yyvsp[-3]).parse, (yyvsp[-1]).parse ); }
+    break;
+
+  case 19:
 #line 175 "jamgram.y"
-{ yyval.parse = pswitch( yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 19:
+    { (yyval).parse = pswitch( (yyvsp[-3]).parse, (yyvsp[-1]).parse ); }
+    break;
+
+  case 20:
 #line 177 "jamgram.y"
-{ yyval.parse = pif( yyvsp[-3].parse, yyvsp[-1].parse, pnull() ); }
-break;
-case 20:
+    { (yyval).parse = pif( (yyvsp[-3]).parse, (yyvsp[-1]).parse, pnull() ); }
+    break;
+
+  case 21:
 #line 179 "jamgram.y"
-{ yyval.parse = pif( yyvsp[-5].parse, yyvsp[-3].parse, yyvsp[0].parse ); }
-break;
-case 21:
+    { (yyval).parse = pif( (yyvsp[-5]).parse, (yyvsp[-3]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 22:
 #line 181 "jamgram.y"
-{ yyval.parse = pwhile( yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 22:
+    { (yyval).parse = pwhile( (yyvsp[-3]).parse, (yyvsp[-1]).parse ); }
+    break;
+
+  case 23:
 #line 183 "jamgram.y"
-{ yyval.parse = psetc( yyvsp[-4].string, yyvsp[-3].parse, yyvsp[-1].parse ); }
-break;
-case 23:
+    { (yyval).parse = psetc( (yyvsp[-4]).string, (yyvsp[-3]).parse, (yyvsp[-1]).parse ); }
+    break;
+
+  case 24:
 #line 185 "jamgram.y"
-{ yyval.parse = pon( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 24:
+    { (yyval).parse = pon( (yyvsp[-1]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 25:
 #line 187 "jamgram.y"
-{ yymode( SCAN_STRING ); }
-break;
-case 25:
+    { yymode( SCAN_STRING ); }
+    break;
+
+  case 26:
 #line 189 "jamgram.y"
-{ yymode( SCAN_NORMAL ); }
-break;
-case 26:
+    { yymode( SCAN_NORMAL ); }
+    break;
+
+  case 27:
 #line 191 "jamgram.y"
-{ yyval.parse = psete( yyvsp[-6].string,yyvsp[-5].parse,yyvsp[-2].string,yyvsp[-7].number ); }
-break;
-case 27:
+    { (yyval).parse = psete( (yyvsp[-6]).string,(yyvsp[-5]).parse,(yyvsp[-2]).string,(yyvsp[-7]).number ); }
+    break;
+
+  case 28:
 #line 199 "jamgram.y"
-{ yyval.number = VAR_SET; }
-break;
-case 28:
+    { (yyval).number = VAR_SET; }
+    break;
+
+  case 29:
 #line 201 "jamgram.y"
-{ yyval.number = VAR_APPEND; }
-break;
-case 29:
+    { (yyval).number = VAR_APPEND; }
+    break;
+
+  case 30:
 #line 203 "jamgram.y"
-{ yyval.number = VAR_DEFAULT; }
-break;
-case 30:
+    { (yyval).number = VAR_DEFAULT; }
+    break;
+
+  case 31:
 #line 205 "jamgram.y"
-{ yyval.number = VAR_DEFAULT; }
-break;
-case 31:
+    { (yyval).number = VAR_DEFAULT; }
+    break;
+
+  case 32:
 #line 213 "jamgram.y"
-{ yyval.parse = peval( EXPR_EXISTS, yyvsp[0].parse, pnull() ); }
-break;
-case 32:
+    { (yyval).parse = peval( EXPR_EXISTS, (yyvsp[0]).parse, pnull() ); }
+    break;
+
+  case 33:
 #line 215 "jamgram.y"
-{ yyval.parse = peval( EXPR_EQUALS, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 33:
+    { (yyval).parse = peval( EXPR_EQUALS, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 34:
 #line 217 "jamgram.y"
-{ yyval.parse = peval( EXPR_NOTEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 34:
+    { (yyval).parse = peval( EXPR_NOTEQ, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 35:
 #line 219 "jamgram.y"
-{ yyval.parse = peval( EXPR_LESS, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 35:
+    { (yyval).parse = peval( EXPR_LESS, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 36:
 #line 221 "jamgram.y"
-{ yyval.parse = peval( EXPR_LESSEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 36:
+    { (yyval).parse = peval( EXPR_LESSEQ, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 37:
 #line 223 "jamgram.y"
-{ yyval.parse = peval( EXPR_MORE, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 37:
+    { (yyval).parse = peval( EXPR_MORE, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 38:
 #line 225 "jamgram.y"
-{ yyval.parse = peval( EXPR_MOREEQ, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 38:
+    { (yyval).parse = peval( EXPR_MOREEQ, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 39:
 #line 227 "jamgram.y"
-{ yyval.parse = peval( EXPR_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 39:
+    { (yyval).parse = peval( EXPR_AND, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 40:
 #line 229 "jamgram.y"
-{ yyval.parse = peval( EXPR_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 40:
+    { (yyval).parse = peval( EXPR_AND, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 41:
 #line 231 "jamgram.y"
-{ yyval.parse = peval( EXPR_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 41:
+    { (yyval).parse = peval( EXPR_OR, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 42:
 #line 233 "jamgram.y"
-{ yyval.parse = peval( EXPR_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 42:
+    { (yyval).parse = peval( EXPR_OR, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 43:
 #line 235 "jamgram.y"
-{ yyval.parse = peval( EXPR_IN, yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 43:
+    { (yyval).parse = peval( EXPR_IN, (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 44:
 #line 237 "jamgram.y"
-{ yyval.parse = peval( EXPR_NOT, yyvsp[0].parse, pnull() ); }
-break;
-case 44:
+    { (yyval).parse = peval( EXPR_NOT, (yyvsp[0]).parse, pnull() ); }
+    break;
+
+  case 45:
 #line 239 "jamgram.y"
-{ yyval.parse = yyvsp[-1].parse; }
-break;
-case 45:
+    { (yyval).parse = (yyvsp[-1]).parse; }
+    break;
+
+  case 46:
 #line 249 "jamgram.y"
-{ yyval.parse = P0; }
-break;
-case 46:
+    { (yyval).parse = P0; }
+    break;
+
+  case 47:
 #line 251 "jamgram.y"
-{ yyval.parse = pnode( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 47:
+    { (yyval).parse = pnode( (yyvsp[-1]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 48:
 #line 255 "jamgram.y"
-{ yyval.parse = psnode( yyvsp[-2].string, yyvsp[0].parse ); }
-break;
-case 48:
+    { (yyval).parse = psnode( (yyvsp[-2]).string, (yyvsp[0]).parse ); }
+    break;
+
+  case 49:
 #line 264 "jamgram.y"
-{ yyval.parse = P0; }
-break;
-case 49:
+    { (yyval).parse = P0; }
+    break;
+
+  case 50:
 #line 266 "jamgram.y"
-{ yyval.parse = psnode( yyvsp[-2].string, yyvsp[0].parse ); }
-break;
-case 50:
+    { (yyval).parse = psnode( (yyvsp[-2]).string, (yyvsp[0]).parse ); }
+    break;
+
+  case 51:
 #line 268 "jamgram.y"
-{ yyval.parse = psnode( yyvsp[0].string, P0 ); }
-break;
-case 51:
+    { (yyval).parse = psnode( (yyvsp[0]).string, P0 ); }
+    break;
+
+  case 52:
 #line 277 "jamgram.y"
-{ yyval.parse = pnode( P0, yyvsp[0].parse ); }
-break;
-case 52:
+    { (yyval).parse = pnode( P0, (yyvsp[0]).parse ); }
+    break;
+
+  case 53:
 #line 279 "jamgram.y"
-{ yyval.parse = pnode( yyvsp[0].parse, yyvsp[-2].parse ); }
-break;
-case 53:
+    { (yyval).parse = pnode( (yyvsp[0]).parse, (yyvsp[-2]).parse ); }
+    break;
+
+  case 54:
 #line 289 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; yymode( SCAN_NORMAL ); }
-break;
-case 54:
+    { (yyval).parse = (yyvsp[0]).parse; yymode( SCAN_NORMAL ); }
+    break;
+
+  case 55:
 #line 293 "jamgram.y"
-{ yyval.parse = pnull(); yymode( SCAN_PUNCT ); }
-break;
-case 55:
+    { (yyval).parse = pnull(); yymode( SCAN_PUNCT ); }
+    break;
+
+  case 56:
 #line 295 "jamgram.y"
-{ yyval.parse = pappend( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 56:
+    { (yyval).parse = pappend( (yyvsp[-1]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 57:
 #line 299 "jamgram.y"
-{ yyval.parse = plist( yyvsp[0].string ); }
-break;
-case 57:
+    { (yyval).parse = plist( (yyvsp[0]).string ); }
+    break;
+
+  case 58:
 #line 300 "jamgram.y"
-{ yymode( SCAN_NORMAL ); }
-break;
-case 58:
+    { yymode( SCAN_NORMAL ); }
+    break;
+
+  case 59:
 #line 301 "jamgram.y"
-{ yyval.parse = yyvsp[-1].parse; }
-break;
-case 59:
+    { (yyval).parse = (yyvsp[-1]).parse; }
+    break;
+
+  case 60:
 #line 310 "jamgram.y"
-{ yyval.parse = prule( yyvsp[-1].parse, yyvsp[0].parse ); }
-break;
-case 60:
+    { (yyval).parse = prule( (yyvsp[-1]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 61:
 #line 312 "jamgram.y"
-{ yyval.parse = pon( yyvsp[-2].parse, prule( yyvsp[-1].parse, yyvsp[0].parse ) ); }
-break;
-case 61:
+    { (yyval).parse = pon( (yyvsp[-2]).parse, prule( (yyvsp[-1]).parse, (yyvsp[0]).parse ) ); }
+    break;
+
+  case 62:
 #line 314 "jamgram.y"
-{ yyval.parse = pon( yyvsp[-2].parse, yyvsp[0].parse ); }
-break;
-case 62:
+    { (yyval).parse = pon( (yyvsp[-2]).parse, (yyvsp[0]).parse ); }
+    break;
+
+  case 63:
 #line 323 "jamgram.y"
-{ yyval.number = 0; }
-break;
-case 63:
+    { (yyval).number = 0; }
+    break;
+
+  case 64:
 #line 325 "jamgram.y"
-{ yyval.number = yyvsp[-1].number | yyvsp[0].number; }
-break;
-case 64:
+    { (yyval).number = (yyvsp[-1]).number | (yyvsp[0]).number; }
+    break;
+
+  case 65:
 #line 329 "jamgram.y"
-{ yyval.number = RULE_UPDATED; }
-break;
-case 65:
+    { (yyval).number = RULE_UPDATED; }
+    break;
+
+  case 66:
 #line 331 "jamgram.y"
-{ yyval.number = RULE_TOGETHER; }
-break;
-case 66:
+    { (yyval).number = RULE_TOGETHER; }
+    break;
+
+  case 67:
 #line 333 "jamgram.y"
-{ yyval.number = RULE_IGNORE; }
-break;
-case 67:
+    { (yyval).number = RULE_IGNORE; }
+    break;
+
+  case 68:
 #line 335 "jamgram.y"
-{ yyval.number = RULE_QUIETLY; }
-break;
-case 68:
+    { (yyval).number = RULE_QUIETLY; }
+    break;
+
+  case 69:
 #line 337 "jamgram.y"
-{ yyval.number = RULE_PIECEMEAL; }
-break;
-case 69:
+    { (yyval).number = RULE_PIECEMEAL; }
+    break;
+
+  case 70:
 #line 339 "jamgram.y"
-{ yyval.number = RULE_EXISTING; }
-break;
-case 70:
+    { (yyval).number = RULE_EXISTING; }
+    break;
+
+  case 71:
 #line 341 "jamgram.y"
-{ yyval.number = atoi( yyvsp[0].string ) * RULE_MAXLINE; }
-break;
-case 71:
+    { (yyval).number = atoi( (yyvsp[0]).string ) * RULE_MAXLINE; }
+    break;
+
+  case 72:
 #line 350 "jamgram.y"
-{ yyval.parse = pnull(); }
-break;
-case 72:
+    { (yyval).parse = pnull(); }
+    break;
+
+  case 73:
 #line 352 "jamgram.y"
-{ yyval.parse = yyvsp[0].parse; }
-break;
-#line 877 "y.tab.c"
-    }
-    yyssp -= yym;
-    yystate = *yyssp;
-    yyvsp -= yym;
-    yym = yylhs[yyn];
-    if (yystate == 0 && yym == 0)
+    { (yyval).parse = (yyvsp[0]).parse; }
+    break;
+
+
+      default: break;
+    }
+
+/* Line 1126 of yacc.c.  */
+#line 1734 "y.tab.c"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+
+
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
     {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: after reduction, shifting from state 0 to\
- state %d\n", YYPREFIX, YYFINAL);
-#endif
-        yystate = YYFINAL;
-        *++yyssp = YYFINAL;
-        *++yyvsp = yyval;
-        if (yychar < 0)
-        {
-            if ((yychar = yylex()) < 0) yychar = 0;
-#if YYDEBUG
-            if (yydebug)
-            {
-                yys = 0;
-                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-                if (!yys) yys = "illegal-symbol";
-                printf("%sdebug: state %d, reading %d (%s)\n",
-                        YYPREFIX, YYFINAL, yychar, yys);
-            }
+      ++yynerrs;
+#if YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
+	{
+	  int yytype = YYTRANSLATE (yychar);
+	  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+	  YYSIZE_T yysize = yysize0;
+	  YYSIZE_T yysize1;
+	  int yysize_overflow = 0;
+	  char *yymsg = 0;
+#	  define YYERROR_VERBOSE_ARGS_MAXIMUM 5
+	  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+	  int yyx;
+
+#if 0
+	  /* This is so xgettext sees the translatable formats that are
+	     constructed on the fly.  */
+	  YY_("syntax error, unexpected %s");
+	  YY_("syntax error, unexpected %s, expecting %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 #endif
+	  char *yyfmt;
+	  char const *yyf;
+	  static char const yyunexpected[] = "syntax error, unexpected %s";
+	  static char const yyexpecting[] = ", expecting %s";
+	  static char const yyor[] = " or %s";
+	  char yyformat[sizeof yyunexpected
+			+ sizeof yyexpecting - 1
+			+ ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+			   * (sizeof yyor - 1))];
+	  char const *yyprefix = yyexpecting;
+
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  int yyxbegin = yyn < 0 ? -yyn : 0;
+
+	  /* Stay within bounds of both yycheck and yytname.  */
+	  int yychecklim = YYLAST - yyn;
+	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+	  int yycount = 1;
+
+	  yyarg[0] = yytname[yytype];
+	  yyfmt = yystpcpy (yyformat, yyunexpected);
+
+	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	      {
+		if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+		  {
+		    yycount = 1;
+		    yysize = yysize0;
+		    yyformat[sizeof yyunexpected - 1] = '\0';
+		    break;
+		  }
+		yyarg[yycount++] = yytname[yyx];
+		yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+		yysize_overflow |= yysize1 < yysize;
+		yysize = yysize1;
+		yyfmt = yystpcpy (yyfmt, yyprefix);
+		yyprefix = yyor;
+	      }
+
+	  yyf = YY_(yyformat);
+	  yysize1 = yysize + yystrlen (yyf);
+	  yysize_overflow |= yysize1 < yysize;
+	  yysize = yysize1;
+
+	  if (!yysize_overflow && yysize <= YYSTACK_ALLOC_MAXIMUM)
+	    yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg)
+	    {
+	      /* Avoid sprintf, as that infringes on the user's name space.
+		 Don't have undefined behavior even if the translation
+		 produced a string with the wrong number of "%s"s.  */
+	      char *yyp = yymsg;
+	      int yyi = 0;
+	      while ((*yyp = *yyf))
+		{
+		  if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		    {
+		      yyp += yytnamerr (yyp, yyarg[yyi++]);
+		      yyf += 2;
+		    }
+		  else
+		    {
+		      yyp++;
+		      yyf++;
+		    }
+		}
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
+	    }
+	  else
+	    {
+	      yyerror (YY_("syntax error"));
+	      goto yyexhaustedlab;
+	    }
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror (YY_("syntax error"));
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
         }
-        if (yychar == 0) goto yyaccept;
-        goto yyloop;
+      else
+	{
+	  yydestruct ("Error: discarding", yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
     }
-    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
-        yystate = yytable[yyn];
-    else
-        yystate = yydgoto[yym];
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: after reduction, shifting from state %d \
-to state %d\n", YYPREFIX, *yyssp, yystate);
-#endif
-    if (yyssp >= yysslim && yygrowstack())
-    {
-        goto yyoverflow;
-    }
-    *++yyssp = yystate;
-    *++yyvsp = yyval;
-    goto yyloop;
-yyoverflow:
-    yyerror("yacc stack overflow");
-yyabort:
-    return (1);
-yyaccept:
-    return (0);
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (0)
+     goto yyerrorlab;
+
+yyvsp -= yylen;
+  yyssp -= yylen;
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping", yystos[yystate], yyvsp);
+      YYPOPSTACK;
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token. */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK;
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
 }
+
+
+
--- ftjam-2.5.2.orig/jamgram.h
+++ ftjam-2.5.2/jamgram.h
@@ -1,51 +1,143 @@
-#ifndef YYERRCODE
-#define YYERRCODE 256
-#endif
+/* A Bison parser, made by GNU Bison 2.1.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
 
-#define _LANGLE_t 257
-#define _LANGLE_EQUALS_t 258
-#define _EQUALS_t 259
-#define _RANGLE_t 260
-#define _RANGLE_EQUALS_t 261
-#define _BAR_t 262
-#define _BARBAR_t 263
-#define _SEMIC_t 264
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     _BANG_t = 258,
+     _BANG_EQUALS_t = 259,
+     _AMPER_t = 260,
+     _AMPERAMPER_t = 261,
+     _LPAREN_t = 262,
+     _RPAREN_t = 263,
+     _PLUS_EQUALS_t = 264,
+     _COLON_t = 265,
+     _SEMIC_t = 266,
+     _LANGLE_t = 267,
+     _LANGLE_EQUALS_t = 268,
+     _EQUALS_t = 269,
+     _RANGLE_t = 270,
+     _RANGLE_EQUALS_t = 271,
+     _QUESTION_EQUALS_t = 272,
+     _LBRACKET_t = 273,
+     _RBRACKET_t = 274,
+     ACTIONS_t = 275,
+     BIND_t = 276,
+     BREAK_t = 277,
+     CASE_t = 278,
+     CONTINUE_t = 279,
+     DEFAULT_t = 280,
+     ELSE_t = 281,
+     EXISTING_t = 282,
+     FOR_t = 283,
+     IF_t = 284,
+     IGNORE_t = 285,
+     IN_t = 286,
+     INCLUDE_t = 287,
+     LOCAL_t = 288,
+     MAXLINE_t = 289,
+     ON_t = 290,
+     PIECEMEAL_t = 291,
+     QUIETLY_t = 292,
+     RETURN_t = 293,
+     RULE_t = 294,
+     SWITCH_t = 295,
+     TOGETHER_t = 296,
+     UPDATED_t = 297,
+     WHILE_t = 298,
+     _LBRACE_t = 299,
+     _BAR_t = 300,
+     _BARBAR_t = 301,
+     _RBRACE_t = 302,
+     ARG = 303,
+     STRING = 304
+   };
+#endif
+/* Tokens.  */
+#define _BANG_t 258
+#define _BANG_EQUALS_t 259
+#define _AMPER_t 260
+#define _AMPERAMPER_t 261
+#define _LPAREN_t 262
+#define _RPAREN_t 263
+#define _PLUS_EQUALS_t 264
 #define _COLON_t 265
-#define _BANG_t 266
-#define _BANG_EQUALS_t 267
-#define _QUESTION_EQUALS_t 268
-#define _LPAREN_t 269
-#define _RPAREN_t 270
-#define _LBRACKET_t 271
-#define _RBRACKET_t 272
-#define _LBRACE_t 273
-#define _RBRACE_t 274
-#define _AMPER_t 275
-#define _AMPERAMPER_t 276
-#define _PLUS_EQUALS_t 277
-#define ACTIONS_t 278
-#define BIND_t 279
-#define BREAK_t 280
-#define CASE_t 281
-#define CONTINUE_t 282
-#define DEFAULT_t 283
-#define ELSE_t 284
-#define EXISTING_t 285
-#define FOR_t 286
-#define IF_t 287
-#define IGNORE_t 288
-#define IN_t 289
-#define INCLUDE_t 290
-#define LOCAL_t 291
-#define MAXLINE_t 292
-#define ON_t 293
-#define PIECEMEAL_t 294
-#define QUIETLY_t 295
-#define RETURN_t 296
-#define RULE_t 297
-#define SWITCH_t 298
-#define TOGETHER_t 299
-#define UPDATED_t 300
-#define WHILE_t 301
-#define ARG 302
-#define STRING 303
+#define _SEMIC_t 266
+#define _LANGLE_t 267
+#define _LANGLE_EQUALS_t 268
+#define _EQUALS_t 269
+#define _RANGLE_t 270
+#define _RANGLE_EQUALS_t 271
+#define _QUESTION_EQUALS_t 272
+#define _LBRACKET_t 273
+#define _RBRACKET_t 274
+#define ACTIONS_t 275
+#define BIND_t 276
+#define BREAK_t 277
+#define CASE_t 278
+#define CONTINUE_t 279
+#define DEFAULT_t 280
+#define ELSE_t 281
+#define EXISTING_t 282
+#define FOR_t 283
+#define IF_t 284
+#define IGNORE_t 285
+#define IN_t 286
+#define INCLUDE_t 287
+#define LOCAL_t 288
+#define MAXLINE_t 289
+#define ON_t 290
+#define PIECEMEAL_t 291
+#define QUIETLY_t 292
+#define RETURN_t 293
+#define RULE_t 294
+#define SWITCH_t 295
+#define TOGETHER_t 296
+#define UPDATED_t 297
+#define WHILE_t 298
+#define _LBRACE_t 299
+#define _BAR_t 300
+#define _BARBAR_t 301
+#define _RBRACE_t 302
+#define ARG 303
+#define STRING 304
+
+
+
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
+
+
--- ftjam-2.5.2.orig/Jamfile.html
+++ ftjam-2.5.2/Jamfile.html
@@ -290,7 +290,7 @@
               for automatic customizing with autoconf(GNU).
 <P>
 	<LI> 	Optionally, set an environment variable pointing
-		to the root directory of the srouce tree. The
+		to the root directory of the source tree. The
 		variable's name is left up to you, but in these
 		examples, we use TOP.
 </OL>
--- ftjam-2.5.2.orig/jambase.c
+++ ftjam-2.5.2/jambase.c
@@ -660,7 +660,7 @@
 "CRELIB      ?= ;\n",
 "DOT     ?= . ;\n",
 "DOTDOT      ?= .. ;\n",
-"EXEMODE     ?= 711 ;\n",
+"EXEMODE     ?= 755 ;\n",
 "FILEMODE    ?= 644 ;\n",
 "FORTRAN     ?= f77 ;\n",
 "FORTRANFLAGS    ?= ;\n",
@@ -1370,7 +1370,7 @@
 "\n",
 "rule Setuid\n",
 "{\n",
-"MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4711 ;\n",
+"MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4755 ;\n",
 "}\n",
 "\n",
 "rule Shell\n",
@@ -1536,7 +1536,7 @@
 "\n",
 "rule UserObject\n",
 "{\n",
-"Exit \"Unknown suffix on\" $(>) \"- see UserObject rule in Jamfile(5).\" ;\n",
+"Exit \"Unknown suffix on\" $(>) \"- see UserObject rule in /usr/share/doc/ftjam/Jamfile.html.\" ;\n",
 "}\n",
 "\n",
 "rule Yacc\n",
--- ftjam-2.5.2.orig/jamgram.y
+++ ftjam-2.5.2/jamgram.y
@@ -1,24 +1,20 @@
+%token _BANG_t
+%token _BANG_EQUALS_t
+%token _AMPER_t
+%token _AMPERAMPER_t
+%token _LPAREN_t
+%token _RPAREN_t
+%token _PLUS_EQUALS_t
+%token _COLON_t
+%token _SEMIC_t
 %token _LANGLE_t
 %token _LANGLE_EQUALS_t
 %token _EQUALS_t
 %token _RANGLE_t
 %token _RANGLE_EQUALS_t
-%token _BAR_t
-%token _BARBAR_t
-%token _SEMIC_t
-%token _COLON_t
-%token _BANG_t
-%token _BANG_EQUALS_t
 %token _QUESTION_EQUALS_t
-%token _LPAREN_t
-%token _RPAREN_t
 %token _LBRACKET_t
 %token _RBRACKET_t
-%token _LBRACE_t
-%token _RBRACE_t
-%token _AMPER_t
-%token _AMPERAMPER_t
-%token _PLUS_EQUALS_t
 %token ACTIONS_t
 %token BIND_t
 %token BREAK_t
@@ -43,6 +39,10 @@
 %token TOGETHER_t
 %token UPDATED_t
 %token WHILE_t
+%token _LBRACE_t
+%token _BAR_t
+%token _BARBAR_t
+%token _RBRACE_t
 /*
  * Copyright 1993-2002 Christopher Seiwald and Perforce Software, Inc.
  *
--- ftjam-2.5.2.orig/debian/changelog
+++ ftjam-2.5.2/debian/changelog
@@ -0,0 +1,76 @@
+ftjam (2.5.2-1.1) unstable; urgency=low
+
+  * Non-maintainer upload.
+  * Applied patch from Brian M. Carlson to build with -fno-strict-aliasing.
+    (closes: #372470)
+
+ -- Frederic Peters <fpeters@debian.org>  Sat, 29 Sep 2007 23:30:27 +0200
+
+ftjam (2.5.2-1) unstable; urgency=low
+
+  * New upstream release.
+  * Sync'd patches and packaging from jam_2.5rel-1.
+  * Fixed Jamrules.in to workaround autoconfiscation problem.
+  * Updated extended description to match the jam one.
+  * Updated debian/watch.
+  * Updated to debhedlper v5: use misc:Depends.
+  * Bumbed Standards-Version to 3.7.2, no change.
+
+ -- Yann Dirson <dirson@debian.org>  Thu,  8 Jun 2006 00:00:18 +0200
+
+ftjam (2.3.5-4) unstable; urgency=low
+
+  * Fixed debian/watch not to look at perforce jam.
+  * Bumped Standards-Version to 3.6.1, no change.
+
+ -- Yann Dirson <dirson@debian.org>  Sat, 30 Oct 2004 14:49:11 +0200
+
+ftjam (2.3.5-3) unstable; urgency=low
+
+  * Parametrized package name in manpage and use it in the path to html
+    doc (Closes: #113478).
+  * Tuned copyright file for lintian to be happy.
+
+ -- Yann Dirson <dirson@debian.org>  Wed,  4 Jun 2003 11:50:10 +0200
+
+ftjam (2.3.5-2) unstable; urgency=low
+
+  * Rebuilt with current debhelper, for current policy.
+  * Use debian/compat, build-dep on debhelper 3.4.4.
+  * Use build options as per current policy (-g -O2).
+  * Bumped Standards-Version to 3.5.10.
+
+ -- Yann Dirson <dirson@debian.org>  Sun,  1 Jun 2003 22:27:58 +0200
+
+ftjam (2.3.5-1) unstable; urgency=low
+
+  * New package, based on package `jam' (Closes: #112476).
+  * Applied patches from package jam to get executable permissions default
+    to 755 and 4755 instead of 711 and 4711, and to fix a typo in the doc.
+  * Install binary as ftjam to avoid conflicting with jam.
+  * Provide /usr/bin/jam alternative with priority higher than jam.
+  * Conflict with versions of package jam not providing alternative.
+  * Reactivated manpage build from SGML now that the converter works
+    again; added build-dep.
+  * Ensure shipped generated files are rebuilt - build-dep on bison.
+
+ -- Yann Dirson <dirson@debian.org>  Wed, 19 Sep 2001 00:23:02 +0200
+
+jam (2.3.2-2) unstable; urgency=low
+
+  * Added a docbook manpage - include the troff version as well as
+    docbook-to-man (1:2.0.0-8) is currently broken.
+  * Added doc-base support for reference manual.
+  * Added an example rules file for literate programming, that I wrote
+    some time ago.
+
+ -- Yann Dirson <dirson@debian.org>  Wed, 23 May 2001 02:09:52 +0200
+
+jam (2.3.2-1) unstable; urgency=low
+
+  * Initial Release (Closes: #98146).
+  * Jambase: changed default EXEMODE to 755 (was 711), and suid perms to
+    4755 (was 4711).
+  * Be sure to invoke jam0 and yyacc with explicit "./".
+
+ -- Yann Dirson <dirson@debian.org>  Mon, 21 May 2001 08:57:42 +0200
--- ftjam-2.5.2.orig/debian/watch
+++ ftjam-2.5.2/debian/watch
@@ -0,0 +1,2 @@
+version=3
+http://sf.net/freetype/ ftjam-(\d\.[0-9.]*)\.tar.gz
--- ftjam-2.5.2.orig/debian/jam-variant
+++ ftjam-2.5.2/debian/jam-variant
@@ -0,0 +1 @@
+ftjam
\ No newline at end of file
--- ftjam-2.5.2.orig/debian/jam.man.sgml
+++ ftjam-2.5.2/debian/jam.man.sgml
@@ -0,0 +1,254 @@
+<!doctype refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN" [
+
+<!-- Process this file with docbook-to-man to generate an nroff manual
+     page: `docbook-to-man manpage.sgml > manpage.1'.  You may view
+     the manual page with: `docbook-to-man manpage.sgml | nroff -man |
+     less'.  A typical entry in a Makefile or Makefile.am is:
+
+manpage.1: manpage.sgml
+	docbook-to-man $< > $@
+  -->
+
+  <!ENTITY dhfirstname "<firstname>Yann</firstname>">
+  <!ENTITY dhsurname   "<surname>Dirson</surname>">
+  <!-- Please adjust the date whenever revising the manpage. -->
+  <!ENTITY dhdate      "<date>mai 23, 2001</date>">
+  <!ENTITY dhemail     "<email>dirson@debian.org</email>">
+  <!ENTITY dhusername  "Yann Dirson">
+  <!ENTITY dhpackage   SYSTEM "./jam-variant">
+
+  <!ENTITY debian      "<productname>Debian GNU/Linux</productname>">
+  <!ENTITY gnu         "<acronym>GNU</acronym>">
+]>
+
+<refentry>
+  <refentryinfo>
+    <address>
+      &dhemail;
+    </address>
+    <author>
+      &dhfirstname;
+      &dhsurname;
+    </author>
+    <copyright>
+      <year>2001</year>
+      <holder>&dhusername;</holder>
+    </copyright>
+    &dhdate;
+  </refentryinfo>
+
+  <refmeta>
+    <refentrytitle>&dhpackage;</refentrytitle>
+    <manvolnum>1</manvolnum>
+  </refmeta>
+
+  <refnamediv>
+    <refname>Jam/MR</refname>
+    <refpurpose>Make(1) Redux</refpurpose>
+  </refnamediv>
+
+  <refsynopsisdiv>
+    <cmdsynopsis>
+      <command>&dhpackage;</command>
+
+      <arg><option>-a</option></arg>
+      <arg><option>-g</option></arg>
+      <arg><option>-n</option></arg>
+      <arg><option>-q</option></arg>
+      <arg><option>-v</option></arg>
+
+      <arg><option>-d <replaceable/debug/</option></arg>
+      <arg><option>-f <replaceable/jambase/</option></arg>
+      <arg><option>-j <replaceable/jobs/</option></arg>
+      <arg><option>-o <replaceable/actionsfile/</option></arg>
+      <arg><option>-s <replaceable/var/=<replaceable/value/</option></arg>
+      <arg><option>-t <replaceable/target/</option></arg>
+
+      <arg repeat><option><replaceable/target/</option></arg>
+    </cmdsynopsis>
+  </refsynopsisdiv>
+
+  <refsect1>
+    <title>DESCRIPTION</title>
+
+    <para>Jam is a program construction tool, like make(1).</para>
+
+    <para>Jam recursively builds target files from source files, using
+    dependency information and updating actions expressed in the
+    Jambase file, which is written in jam's own interpreted language.
+    The default Jambase is compiled into jam and provides a
+    boilerplate for common use, relying on a user-provide file
+    "Jamfile" to enumerate actual targets and sources.</para>
+  </refsect1>
+
+  <refsect1>
+    <title>OPTIONS</title>
+
+    <variablelist>
+      <varlistentry>
+        <term><option/-a/</term>
+        <listitem>
+          <para>Build all targets anyway, even if they are up-to-date.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-d <replaceable/n/</option></term>
+        <listitem>
+          <para>Enable cummulative debugging levels from 1 to
+	    <replaceable/n/. Interesting values are:
+
+	    <glosslist>
+	      <glossentry><glossterm/1/ <glossdef><simpara/Show
+	      actions (the default)/</glossdef></glossentry>
+
+	      <glossentry><glossterm/2/ <glossdef><simpara/Show
+	      "quiet" actions and display all action
+	      text/</glossdef></glossentry>
+
+	      <glossentry><glossterm/3/ <glossdef><simpara>Show
+	      dependency analysis, and target/source
+	      timestamps/paths</simpara></glossdef></glossentry>
+
+	      <glossentry><glossterm/4/ <glossdef><simpara/Show shell
+	      arguments/</glossdef></glossentry>
+
+	      <glossentry><glossterm/5/ <glossdef><simpara/Show rule
+	      invocations and variable
+	      expansions/</glossdef></glossentry>
+
+	      <glossentry><glossterm/6/ <glossdef><simpara>Show
+	      directory/header file/archive
+	      scans</simpara></glossdef></glossentry>
+
+	      <glossentry><glossterm/7/ <glossdef><simpara/Show
+	      variable settings/</glossdef></glossentry>
+
+	      <glossentry><glossterm/8/ <glossdef><simpara/Show
+	      variable fetches/</glossdef></glossentry>
+
+	      <glossentry><glossterm/9/ <glossdef><simpara/Show
+	      variable manipulation, scanner
+	      tokens/</glossdef></glossentry>
+	    </glosslist>
+	  </para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-d +<replaceable/n/</option></term>
+        <listitem>
+          <para>Enable debugging level <replaceable/n/.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option/-d 0/</term>
+        <listitem>
+          <para>Turn off all debugging levels. Only errors are not
+          suppressed.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-f <replaceable/jambase/</option></term>
+        <listitem>
+          <para>Read <replaceable/jambase/ instead of using the
+          built-in Jambase. Only one <option/-f/ flag is permitted,
+          but the <replaceable/jambase/ may explicitly include other
+          files.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-g</option></term>
+        <listitem>
+          <para>Build targets with the newest sources first, rather than
+	    in the order of appearance in the Jambase/Jamfiles.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-j <replaceable/n/</option></term>
+        <listitem>
+          <para>Run up to <replaceable/n/ shell commands concurrently
+          (UNIX and NT only). The default is 1.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option/-n/</term>
+        <listitem>
+          <para>Don't actually execute the updating actions, but do
+          everything else. This changes the debug level default to
+          <option/-d2/.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-o <replaceable/file/</option></term>
+        <listitem>
+          <para>Write the updating actions to the specified file
+          instead of running them (or outputting them, as on the
+          Mac).</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-q</option></term>
+        <listitem>
+          <para>Quit quickly (as if an interrupt was received)
+	    as soon as any target build fails.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-s <replaceable/var/=<replaceable/value/</option></term>
+        <listitem>
+          <para>Set the variable <replaceable/var/ to
+          <replaceable/value/, overriding both internal variables and
+          variables imported from the environment. </para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-t <replaceable/target/</option></term>
+        <listitem>
+          <para>Rebuild <replaceable/target/ and everything that
+          depends on it, even if it is up-to-date.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option/-v/</term>
+        <listitem>
+          <para>Print the version of &dhpackage; and exit.</para>
+        </listitem>
+      </varlistentry>
+
+    </variablelist>
+  </refsect1>
+
+  <refsect1>
+    <title>SEE ALSO</title>
+
+    <para>&dhpackage; is documented fully in HTML pages available on Debian
+    systems from
+    <filename>/usr/share/doc/&dhpackage;/Jam.html</filename>.</para>
+  </refsect1>
+
+  <refsect1>
+    <title>AUTHOR</title>
+
+    <para>This manual page was created by &dhusername; &dhemail; from
+    the <filename/Jam.html/ documentation, for the &debian; system
+    (but may be used by others).</para>
+  </refsect1>
+</refentry>
+
+<!-- Keep this comment at the end of the file
+Local variables:
+sgml-omittag:t
+sgml-shorttag:t
+End:
+-->
--- ftjam-2.5.2.orig/debian/README.Debian
+++ ftjam-2.5.2/debian/README.Debian
@@ -0,0 +1,9 @@
+The Jambase.gz file contains the default builtin rules for jam.  It is
+often useful as a reference, to understand what's going on, as jam is
+so radically different from make(1).
+
+Other useful docs and tutorials are available through
+http://www.perforce.com/jam/jam.html, in the "White Papers and Examples"
+section.
+
+ -- Yann Dirson <dirson@debian.org>, Wed,  7 Jun 2006 23:39:52 z
--- ftjam-2.5.2.orig/debian/compat
+++ ftjam-2.5.2/debian/compat
@@ -0,0 +1 @@
+5
--- ftjam-2.5.2.orig/debian/control
+++ ftjam-2.5.2/debian/control
@@ -0,0 +1,31 @@
+Source: ftjam
+Section: devel
+Priority: optional
+Maintainer: Yann Dirson <dirson@debian.org>
+Build-Depends: debhelper (>= 5), dh-buildinfo, docbook-to-man, bison
+Standards-Version: 3.7.2
+
+Package: ftjam
+Architecture: any
+Depends: ${shlibs:Depends}, ${misc:Depends}
+Conflicts: jam (<< 2.3.2-3)
+Description: FreeType version of Jam, a replacement for make
+ This is a version of Jam with additional features and bugfixes, which
+ is maintained by the FreeType project.
+ .
+ Perforce's Jam (formerly called Jam/MR, available in package "jam")
+ is a powerful and highly customizable utility to build programs and
+ other things, that can run on Un*x, Nt, VMS, OS/2 and Macintosh MPW,
+ using portable Jamfiles.  It can build large projects spread across
+ many directories in one pass, and can run jobs in parallel where make
+ would not.
+ .
+ It takes some time to fully apprehend, especially when one's already
+ accustomed to make(1), but there's no comparison in power when
+ comparing these two tools.
+ .
+ Standard rules:
+  - can automatically extract header dependencies for C/C++ (you can
+ customize for you own language)
+  - provide for automatic "clean", "install", "uninstall" rules,
+ so that an automake-like tool is not needed
--- ftjam-2.5.2.orig/debian/copyright
+++ ftjam-2.5.2/debian/copyright
@@ -0,0 +1,19 @@
+This package was debianized by Yann Dirson <dirson@debian.org> on
+Sun, 20 May 2001
+
+It was downloaded from http://freetype.sourceforge.net/jam/index.html
+
+Upstream Author: Christopher Seiwald <seiwald@perforce.com>
+Modified by the FreeType project.
+
+Copyright:
+
+ * /+\
+ * +\	Copyright 1993, 2000 Christopher Seiwald.
+ * \+/
+
+ * License is hereby granted to use this software and distribute it
+ * freely, as long as this copyright notice is retained and modifications 
+ * are clearly marked.
+ *
+ * ALL WARRANTIES ARE HEREBY DISCLAIMED.
--- ftjam-2.5.2.orig/debian/rules
+++ ftjam-2.5.2/debian/rules
@@ -0,0 +1,85 @@
+#!/usr/bin/make -f
+# Sample debian/rules that uses debhelper.
+# GNU copyright 1997 to 1999 by Joey Hess.
+# GNU copyright 2001 by Yann Dirson.
+
+# This is the debian/rules file for packages jam and ftjam
+# It should be usable with both packages without any change
+
+# find out package name (jam/ftjam)
+jam = $(strip $(shell dpkg-parsechangelog | grep ^Source: | cut -d: -f2))
+
+# original jam should not get the same name as the alternative
+ifeq (${jam},jam)
+binname = jam.perforce
+else
+binname = ${jam}
+endif
+
+topdir=$(shell pwd)
+
+build: build-stamp
+build-stamp: debian/jam.1
+	dh_testdir
+
+  # bootstrap
+	${MAKE}
+  # update generated files
+	rm jamgram.c jamgram.h
+	${MAKE}
+
+	touch build-stamp
+
+%.1: %.man.sgml
+	/usr/bin/docbook-to-man $< > $@
+
+clean:
+	dh_testdir
+	dh_testroot
+	rm -f build-stamp
+	rm -rf bin.*
+	rm -f jam0 debian/jam.1
+	dh_clean
+
+install: build
+	dh_testdir
+	dh_testroot
+	dh_clean -k
+	dh_installdirs
+
+	# workaround autoconfiscation problem
+	echo 'BINDIR ?= /usr/local/bin ;' > Jamrules
+
+	./jam0  -sBINDIR=${topdir}/debian/${jam}/usr/bin \
+		-sCCFLAGS=-g -sOPTIM=-O2 \
+		install
+	cd debian/${jam}/usr/bin && mv jam ${binname}
+	install -d ${topdir}/debian/${jam}/usr/share/man/man1/
+	install -m644 debian/jam.1 ${topdir}/debian/${jam}/usr/share/man/man1/${binname}.1
+
+
+# Build architecture-independent files here.
+binary-indep: build install
+# We have nothing to do by default.
+
+# Build architecture-dependent files here.
+binary-arch: build install
+	dh_testdir
+	dh_testroot
+	dh_installdocs README RELNOTES Jambase *.html
+	dh_buildinfo
+	dh_installexamples Jamfile debian/Jamrules-*
+#	dh_installemacsen
+#	dh_undocumented
+	dh_installchangelogs 
+	dh_strip
+	dh_compress
+	dh_fixperms
+	dh_installdeb
+	dh_shlibdeps
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install configure
--- ftjam-2.5.2.orig/debian/ftjam.doc-base
+++ ftjam-2.5.2/debian/ftjam.doc-base
@@ -0,0 +1,9 @@
+Document: ftjam
+Title: FT Jam Reference Manual
+Author: Christopher Seiwald + the FreeType project
+Abstract: This manual describes how to use FT Jam, an improved version of Jam/MR, a powerful replacement for make(1).
+Section: Apps/Programming
+
+Format: HTML
+Index: /usr/share/doc/ftjam/Jamfile.html
+Files: /usr/share/doc/ftjam/*.html
--- ftjam-2.5.2.orig/debian/ftjam.postinst
+++ ftjam-2.5.2/debian/ftjam.postinst
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+set -e
+
+update-alternatives --install /usr/bin/jam jam /usr/bin/ftjam 11 \
+    --slave /usr/share/man/man1/jam.1.gz jam.1.gz /usr/share/man/man1/ftjam.1.gz
+
+#DEBHELPER#
--- ftjam-2.5.2.orig/debian/ftjam.prerm
+++ ftjam-2.5.2/debian/ftjam.prerm
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+set -e
+
+update-alternatives --remove jam /usr/bin/ftjam
+
+#DEBHELPER#
--- ftjam-2.5.2.orig/debian/Jamrules-tex
+++ ftjam-2.5.2/debian/Jamrules-tex
@@ -0,0 +1,101 @@
+# Jam rules for Tex and LaTeX
+
+# Usage:
+
+# include "Jamrules-tex" ;
+# Latex foo.tex bar.tex ;
+# Tex hello.tex ;
+
+# Then call jam with one of "pdf", "ps", or "dvi" targets
+
+
+NOTFILE dvi ps pdf ;
+
+rule Latex
+{
+	LatexDvi $(<:S=.dvi) : $(<) ;
+	DviPs $(<:S=.ps) : $(<:S=.dvi) ;
+	Depends dvi : $(<:S=.dvi) ;
+
+	LatexPdf $(<:S=.pdf) : $(<) ;
+	Depends pdf : $(<:S=.pdf) ;
+}
+
+rule Tex
+{
+	TexDvi $(<:S=.dvi) : $(<) ;
+	DviPs $(<:S=.ps) : $(<:S=.dvi) ;
+	Depends dvi : $(<:S=.dvi) ;
+
+	TexPdf $(<:S=.pdf) : $(<) ;
+	Depends pdf : $(<:S=.pdf) ;
+}
+
+rule LatexDvi
+{
+	Depends $(<) : $(>) ;
+	Clean clean : $(<) $(<:S=.log) $(<:S=.toc) $(<:S=.aux) ;
+}
+
+actions LatexDvi
+{
+	# FIXME: should use rlatex
+	while latex $(>) |
+		tee /dev/tty |
+		fgrep "Label(s) may have changed." >/dev/null
+	do :
+	done
+}
+
+rule LatexPdf
+{
+	Depends $(<) : $(>) ;
+	Clean clean : $(<) $(<:S=.log) $(<:S=.toc) $(<:S=.aux) ;
+}
+
+actions LatexPdf
+{
+	while pdflatex $(>) |
+		tee /dev/tty |
+		fgrep "Label(s) may have changed." >/dev/null
+	do :
+	done
+}
+
+rule TexDvi
+{
+	Depends $(<) : $(>) ;
+	Clean clean : $(<) $(<:S=.log) ;
+}
+
+actions TexDvi
+{
+	tex $(>)
+}
+
+rule TexPdf
+{
+	Depends $(<) : $(>) ;
+	Depends all : $(<) ;
+	Depends pdf : $(<) ;
+	Clean clean : $(<) $(<:S=.log) ;
+}
+
+actions TexPdf
+{
+	pdftex $(>)
+}
+
+
+rule DviPs
+{
+	Depends $(<) : $(>) ;
+	Depends all : $(<) ;
+	Depends ps : $(<) ;
+	Clean clean : $(<) ;
+}
+
+actions DviPs
+{
+	dvips $(>) -o $(<)
+}
--- ftjam-2.5.2.orig/debian/Jamrules-bigloo
+++ ftjam-2.5.2/debian/Jamrules-bigloo
@@ -0,0 +1,47 @@
+# Jam rules for the bigloo scheme compiler
+# (c) 2003 Yann Dirson
+
+# Usage:
+#
+# BiglooMain foo : foo.scm bar.scm ;
+#
+#  or:
+#
+# LINK = $(BIGLOO)
+# Main foo : foo.scm bar.scm ;
+
+
+# TODO:
+# - header scanning
+# - find a way to get rid of BiglooMain, whose sole purpose is to
+# assign a correct value to LINK
+# - many files are rebuilt several times with no apparent reason
+
+BIGLOO ?= bigloo ;
+BFLAGS ?= "" ;
+
+rule BiglooMain
+{
+	Main $(<) : $(>) ;
+	LINK on $(<) = $(BIGLOO) ;
+}
+
+rule Bigloo
+{
+	DEPENDS $(<) : $(>) ;
+	Clean clean : $(<) $(<:S=.c) ;
+}
+
+actions Bigloo
+{
+	bigloo $(BFLAGS) -c -o $(<) $(>)
+}
+
+rule UserObject
+{
+	switch $(>)
+	{
+	case *.scm	: Bigloo $(<) : $(>) ;
+	case *		: ECHO "unknown suffix on" $(>) ;
+	}
+}
--- ftjam-2.5.2.orig/debian/Jamrules-cweb
+++ ftjam-2.5.2/debian/Jamrules-cweb
@@ -0,0 +1,45 @@
+# Jam rules for Cweb
+
+# Usage:
+
+# include "Jamrules-cweb" ;
+# FwebProducts main.c util.c : foo.w ;
+
+
+#  Ideally we should not have to explicitely to use the *Products rules,
+# but I don't know yet how to autocompute files to be produced.  Could this
+# be a Jam limitation ?
+#  For now the *Products rules are used to trigger the weave process.  They
+# should be invoked by the same wrappers that should invoke *Products.
+
+NOTFILE tex ;
+
+rule CwebProducts
+{
+	# tangle
+	Depends $(<) : $(>) ;
+	Depends all : $(<) ;
+	Clean clean : $(<) ;
+
+	# weave
+	CwebLatex $(>:S=.tex) : $(>) ;
+	Depends tex : $(>:S=.tex) ;
+}
+
+actions CwebProducts
+{
+	ctangle $(>)
+}
+
+
+rule CwebLatex
+{
+	Depends $(<) : $(>) ;
+	Clean clean : $(<) $(<:S=.idx) $(<:S=.scn) ;
+	# FIXME: the following should be autodetected by LatexDvi instead
+	Depends $(<:S=.dvi) : $(<:S=.idx) $(<:S=.scn) ;
+
+	Latex $(<) ;
+}
+
+actions CwebLatex { cweave $(>) }
--- ftjam-2.5.2.orig/debian/Jamrules-funnelweb
+++ ftjam-2.5.2/debian/Jamrules-funnelweb
@@ -0,0 +1,67 @@
+# Jam rules for Funnelweb
+
+# Usage:
+
+# include "Jamrules-funnelweb" ;
+# FwebProducts main.c util.c : foo.fw ;
+
+
+#  Ideally we should not have to explicitely to use the *Products rules,
+# but I don't know yet how to autocompute files to be produced.  Could this
+# be a Jam limitation ?
+#  For now the *Products rules are used to trigger the weave process.  They
+# should be invoked by the same wrappers that should invoke *Products.
+
+NOTFILE tex html ;
+
+#  note: we attempt to emulate standard UN*X behaviour by using the .lis
+# output file, which we do not leave behind.
+
+rule FunnelwebProducts
+{
+	Depends $(<) : $(>) ;
+	Depends all : $(<) ;
+	Clean clean : $(<) ;
+
+	# weave
+	FunnelwebTex $(>:S=.tex) : $(>) ;
+	FunnelwebHtml $(>:S=.html) : $(>) ;
+	Depends tex : $(>:S=.tex) ;
+	Depends html : $(>:S=.html) ;
+}
+
+actions FunnelwebProducts
+{
+	# tangle
+	fw +L $(>)
+	cat $(>:S=.lis)
+	rm -f $(>:S=.lis)
+}
+
+rule FunnelwebTex
+{
+	Depends $(<) : $(>) ;
+	Clean clean : $(<) ;
+
+	Tex $(<) ;
+}
+
+actions FunnelwebTex
+{
+	fw +L -O +T $(>)
+	cat $(>:S=.lis)
+	rm -f $(>:S=.lis)
+}
+
+rule FunnelwebHtml
+{
+	Depends $(<) : $(>) ;
+	Clean clean : $(<) ;
+}
+
+actions FunnelwebHtml
+{
+	fw +L -O +U $(>)
+	cat $(>:S=.lis)
+	rm -f $(>:S=.lis)
+}
--- ftjam-2.5.2.orig/debian/Jamrules-fweb
+++ ftjam-2.5.2/debian/Jamrules-fweb
@@ -0,0 +1,44 @@
+# Jam rules for Fweb
+
+# Usage:
+
+# include "Jamrules-fweb" ;
+# FwebProducts main.c util.c : foo.fweb ;
+
+
+#  Ideally we should not have to explicitely to use the *Products rules,
+# but I don't know yet how to autocompute files to be produced.  Could this
+# be a Jam limitation ?
+#  For now the *Products rules are used to trigger the weave process.  They
+# should be invoked by the same wrappers that should invoke *Products.
+
+NOTFILE tex ;
+
+# FIXME: something should be done to mark MODULES.tex and INDEX.tex
+#  as side-products of the fweb run.
+
+rule FwebProducts
+{
+	# tangle
+	Depends $(<) : $(>) ;
+	Depends all : $(<) ;
+	Clean clean : $(<) ;
+
+	# weave
+	FwebLatex $(>:S=.tex) : $(>) ;
+	Depends tex : $(>:S=.tex) ;
+}
+
+actions FwebProducts { ftangle $(>) }
+
+rule FwebLatex
+{
+	Depends $(<) : $(>) ;
+	Clean clean : $(<) MODULES.tex INDEX.tex ;
+	# FIXME: the following should be autodetected by LatexDvi instead
+	Depends $(<:S=.dvi) : MODULES.tex INDEX.tex ;
+
+	Latex $(<) ;
+}
+
+actions FwebLatex { fweave $(>) }
